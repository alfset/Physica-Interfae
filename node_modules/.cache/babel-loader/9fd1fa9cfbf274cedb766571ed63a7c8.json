{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\nvar invariant = _interopDefault(require('tiny-invariant'));\nvar hash = require('@ethersproject/hash');\nvar bignumber = require('@ethersproject/bignumber');\nvar contracts = require('@ethersproject/contracts');\nvar PERMIT2_ADDRESS = '0xc04f8351c41ccb398Ef07Dd3ed19c2A846c8E3AB';\nvar MaxUint48 = /*#__PURE__*/bignumber.BigNumber.from('0xffffffffffff');\nvar MaxUint160 = /*#__PURE__*/bignumber.BigNumber.from('0xffffffffffffffffffffffffffffffffffffffff');\nvar MaxUint256 = /*#__PURE__*/bignumber.BigNumber.from('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');\n// alias max types for their usages\n// allowance transfer types\nvar MaxAllowanceTransferAmount = MaxUint160;\nvar MaxAllowanceExpiration = MaxUint48;\nvar MaxOrderedNonce = MaxUint48;\n// signature transfer types\nvar MaxSignatureTransferAmount = MaxUint256;\nvar MaxUnorderedNonce = MaxUint256;\nvar MaxSigDeadline = MaxUint256;\nvar InstantExpiration = /*#__PURE__*/bignumber.BigNumber.from(0);\nvar PERMIT2_DOMAIN_NAME = 'Permit2';\nfunction permit2Domain(permit2Address, chainId) {\n  return {\n    name: PERMIT2_DOMAIN_NAME,\n    chainId: chainId,\n    verifyingContract: permit2Address\n  };\n}\nvar PERMIT_DETAILS = [{\n  name: 'token',\n  type: 'address'\n}, {\n  name: 'amount',\n  type: 'uint160'\n}, {\n  name: 'expiration',\n  type: 'uint48'\n}, {\n  name: 'nonce',\n  type: 'uint48'\n}];\nvar PERMIT_TYPES = {\n  PermitSingle: [{\n    name: 'details',\n    type: 'PermitDetails'\n  }, {\n    name: 'spender',\n    type: 'address'\n  }, {\n    name: 'sigDeadline',\n    type: 'uint256'\n  }],\n  PermitDetails: PERMIT_DETAILS\n};\nvar PERMIT_BATCH_TYPES = {\n  PermitBatch: [{\n    name: 'details',\n    type: 'PermitDetails[]'\n  }, {\n    name: 'spender',\n    type: 'address'\n  }, {\n    name: 'sigDeadline',\n    type: 'uint256'\n  }],\n  PermitDetails: PERMIT_DETAILS\n};\nfunction isPermit(permit) {\n  return !Array.isArray(permit.details);\n}\nvar AllowanceTransfer = /*#__PURE__*/function () {\n  /**\n   * Cannot be constructed.\n   */\n  function AllowanceTransfer() {}\n  // return the data to be sent in a eth_signTypedData RPC call\n  // for signing the given permit data\n  AllowanceTransfer.getPermitData = function getPermitData(permit, permit2Address, chainId) {\n    !MaxSigDeadline.gte(permit.sigDeadline) ? invariant(false, 'SIG_DEADLINE_OUT_OF_RANGE') : void 0;\n    var domain = permit2Domain(permit2Address, chainId);\n    if (isPermit(permit)) {\n      validatePermitDetails(permit.details);\n      return {\n        domain: domain,\n        types: PERMIT_TYPES,\n        values: permit\n      };\n    } else {\n      permit.details.forEach(validatePermitDetails);\n      return {\n        domain: domain,\n        types: PERMIT_BATCH_TYPES,\n        values: permit\n      };\n    }\n  };\n  AllowanceTransfer.hash = function hash$1(permit, permit2Address, chainId) {\n    var _AllowanceTransfer$ge = AllowanceTransfer.getPermitData(permit, permit2Address, chainId),\n      domain = _AllowanceTransfer$ge.domain,\n      types = _AllowanceTransfer$ge.types,\n      values = _AllowanceTransfer$ge.values;\n    return hash._TypedDataEncoder.hash(domain, types, values);\n  };\n  return AllowanceTransfer;\n}();\nfunction validatePermitDetails(details) {\n  !MaxOrderedNonce.gte(details.nonce) ? invariant(false, 'NONCE_OUT_OF_RANGE') : void 0;\n  !MaxAllowanceTransferAmount.gte(details.amount) ? invariant(false, 'AMOUNT_OUT_OF_RANGE') : void 0;\n  !MaxAllowanceExpiration.gte(details.expiration) ? invariant(false, 'EXPIRATION_OUT_OF_RANGE') : void 0;\n}\nfunction _regeneratorRuntime() {\n  _regeneratorRuntime = function () {\n    return exports;\n  };\n  var exports = {},\n    Op = Object.prototype,\n    hasOwn = Op.hasOwnProperty,\n    $Symbol = \"function\" == typeof Symbol ? Symbol : {},\n    iteratorSymbol = $Symbol.iterator || \"@@iterator\",\n    asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\",\n    toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n  function define(obj, key, value) {\n    return Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }), obj[key];\n  }\n  try {\n    define({}, \"\");\n  } catch (err) {\n    define = function (obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,\n      generator = Object.create(protoGenerator.prototype),\n      context = new Context(tryLocsList || []);\n    return generator._invoke = function (innerFn, self, context) {\n      var state = \"suspendedStart\";\n      return function (method, arg) {\n        if (\"executing\" === state) throw new Error(\"Generator is already running\");\n        if (\"completed\" === state) {\n          if (\"throw\" === method) throw arg;\n          return doneResult();\n        }\n        for (context.method = method, context.arg = arg;;) {\n          var delegate = context.delegate;\n          if (delegate) {\n            var delegateResult = maybeInvokeDelegate(delegate, context);\n            if (delegateResult) {\n              if (delegateResult === ContinueSentinel) continue;\n              return delegateResult;\n            }\n          }\n          if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) {\n            if (\"suspendedStart\" === state) throw state = \"completed\", context.arg;\n            context.dispatchException(context.arg);\n          } else \"return\" === context.method && context.abrupt(\"return\", context.arg);\n          state = \"executing\";\n          var record = tryCatch(innerFn, self, context);\n          if (\"normal\" === record.type) {\n            if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue;\n            return {\n              value: record.arg,\n              done: context.done\n            };\n          }\n          \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg);\n        }\n      };\n    }(innerFn, self, context), generator;\n  }\n  function tryCatch(fn, obj, arg) {\n    try {\n      return {\n        type: \"normal\",\n        arg: fn.call(obj, arg)\n      };\n    } catch (err) {\n      return {\n        type: \"throw\",\n        arg: err\n      };\n    }\n  }\n  exports.wrap = wrap;\n  var ContinueSentinel = {};\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n  var getProto = Object.getPrototypeOf,\n    NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);\n  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function (method) {\n      define(prototype, method, function (arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (\"throw\" !== record.type) {\n        var result = record.arg,\n          value = result.value;\n        return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) {\n          invoke(\"next\", value, resolve, reject);\n        }, function (err) {\n          invoke(\"throw\", err, resolve, reject);\n        }) : PromiseImpl.resolve(value).then(function (unwrapped) {\n          result.value = unwrapped, resolve(result);\n        }, function (error) {\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n      reject(record.arg);\n    }\n    var previousPromise;\n    this._invoke = function (method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function (resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n      return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n    };\n  }\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (undefined === method) {\n      if (context.delegate = null, \"throw\" === context.method) {\n        if (delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel;\n        context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\");\n      }\n      return ContinueSentinel;\n    }\n    var record = tryCatch(method, delegate.iterator, context.arg);\n    if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel;\n    var info = record.arg;\n    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel);\n  }\n  function pushTryEntry(locs) {\n    var entry = {\n      tryLoc: locs[0]\n    };\n    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);\n  }\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\", delete record.arg, entry.completion = record;\n  }\n  function Context(tryLocsList) {\n    this.tryEntries = [{\n      tryLoc: \"root\"\n    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);\n  }\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) return iteratorMethod.call(iterable);\n      if (\"function\" == typeof iterable.next) return iterable;\n      if (!isNaN(iterable.length)) {\n        var i = -1,\n          next = function next() {\n            for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;\n            return next.value = undefined, next.done = !0, next;\n          };\n        return next.next = next;\n      }\n    }\n    return {\n      next: doneResult\n    };\n  }\n  function doneResult() {\n    return {\n      value: undefined,\n      done: !0\n    };\n  }\n  return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) {\n    var ctor = \"function\" == typeof genFun && genFun.constructor;\n    return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name));\n  }, exports.mark = function (genFun) {\n    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun;\n  }, exports.awrap = function (arg) {\n    return {\n      __await: arg\n    };\n  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    void 0 === PromiseImpl && (PromiseImpl = Promise);\n    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);\n    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {\n      return result.done ? result.value : iter.next();\n    });\n  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () {\n    return this;\n  }), define(Gp, \"toString\", function () {\n    return \"[object Generator]\";\n  }), exports.keys = function (object) {\n    var keys = [];\n    for (var key in object) keys.push(key);\n    return keys.reverse(), function next() {\n      for (; keys.length;) {\n        var key = keys.pop();\n        if (key in object) return next.value = key, next.done = !1, next;\n      }\n      return next.done = !0, next;\n    };\n  }, exports.values = values, Context.prototype = {\n    constructor: Context,\n    reset: function (skipTempReset) {\n      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);\n    },\n    stop: function () {\n      this.done = !0;\n      var rootRecord = this.tryEntries[0].completion;\n      if (\"throw\" === rootRecord.type) throw rootRecord.arg;\n      return this.rval;\n    },\n    dispatchException: function (exception) {\n      if (this.done) throw exception;\n      var context = this;\n      function handle(loc, caught) {\n        return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught;\n      }\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i],\n          record = entry.completion;\n        if (\"root\" === entry.tryLoc) return handle(\"end\");\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\"),\n            hasFinally = hasOwn.call(entry, \"finallyLoc\");\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);\n            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);\n          } else {\n            if (!hasFinally) throw new Error(\"try statement without catch or finally\");\n            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);\n          }\n        }\n      }\n    },\n    abrupt: function (type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n      finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);\n      var record = finallyEntry ? finallyEntry.completion : {};\n      return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);\n    },\n    complete: function (record, afterLoc) {\n      if (\"throw\" === record.type) throw record.arg;\n      return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;\n    },\n    finish: function (finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;\n      }\n    },\n    catch: function (tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (\"throw\" === record.type) {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n      throw new Error(\"illegal catch attempt\");\n    },\n    delegateYield: function (iterable, resultName, nextLoc) {\n      return this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel;\n    }\n  }, exports;\n}\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n      _next(undefined);\n    });\n  };\n}\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nvar TOKEN_PERMISSIONS = [{\n  name: 'token',\n  type: 'address'\n}, {\n  name: 'amount',\n  type: 'uint256'\n}];\nvar PERMIT_TRANSFER_FROM_TYPES = {\n  PermitTransferFrom: [{\n    name: 'permitted',\n    type: 'TokenPermissions'\n  }, {\n    name: 'spender',\n    type: 'address'\n  }, {\n    name: 'nonce',\n    type: 'uint256'\n  }, {\n    name: 'deadline',\n    type: 'uint256'\n  }],\n  TokenPermissions: TOKEN_PERMISSIONS\n};\nvar PERMIT_BATCH_TRANSFER_FROM_TYPES = {\n  PermitBatchTransferFrom: [{\n    name: 'permitted',\n    type: 'TokenPermissions[]'\n  }, {\n    name: 'spender',\n    type: 'address'\n  }, {\n    name: 'nonce',\n    type: 'uint256'\n  }, {\n    name: 'deadline',\n    type: 'uint256'\n  }],\n  TokenPermissions: TOKEN_PERMISSIONS\n};\nfunction permitTransferFromWithWitnessType(witness) {\n  return _extends({\n    PermitWitnessTransferFrom: [{\n      name: 'permitted',\n      type: 'TokenPermissions'\n    }, {\n      name: 'spender',\n      type: 'address'\n    }, {\n      name: 'nonce',\n      type: 'uint256'\n    }, {\n      name: 'deadline',\n      type: 'uint256'\n    }, {\n      name: 'witness',\n      type: witness.witnessTypeName\n    }],\n    TokenPermissions: TOKEN_PERMISSIONS\n  }, witness.witnessType);\n}\nfunction permitBatchTransferFromWithWitnessType(witness) {\n  return _extends({\n    PermitBatchWitnessTransferFrom: [{\n      name: 'permitted',\n      type: 'TokenPermissions[]'\n    }, {\n      name: 'spender',\n      type: 'address'\n    }, {\n      name: 'nonce',\n      type: 'uint256'\n    }, {\n      name: 'deadline',\n      type: 'uint256'\n    }, {\n      name: 'witness',\n      type: witness.witnessTypeName\n    }],\n    TokenPermissions: TOKEN_PERMISSIONS\n  }, witness.witnessType);\n}\nfunction isPermitTransferFrom(permit) {\n  return !Array.isArray(permit.permitted);\n}\nvar SignatureTransfer = /*#__PURE__*/function () {\n  /**\n   * Cannot be constructed.\n   */\n  function SignatureTransfer() {}\n  // return the data to be sent in a eth_signTypedData RPC call\n  // for signing the given permit data\n  SignatureTransfer.getPermitData = function getPermitData(permit, permit2Address, chainId, witness) {\n    !MaxSigDeadline.gte(permit.deadline) ? invariant(false, 'SIG_DEADLINE_OUT_OF_RANGE') : void 0;\n    !MaxUnorderedNonce.gte(permit.nonce) ? invariant(false, 'NONCE_OUT_OF_RANGE') : void 0;\n    var domain = permit2Domain(permit2Address, chainId);\n    if (isPermitTransferFrom(permit)) {\n      validateTokenPermissions(permit.permitted);\n      var types = witness ? permitTransferFromWithWitnessType(witness) : PERMIT_TRANSFER_FROM_TYPES;\n      var values = witness ? Object.assign(permit, {\n        witness: witness.witness\n      }) : permit;\n      return {\n        domain: domain,\n        types: types,\n        values: values\n      };\n    } else {\n      permit.permitted.forEach(validateTokenPermissions);\n      var _types = witness ? permitBatchTransferFromWithWitnessType(witness) : PERMIT_BATCH_TRANSFER_FROM_TYPES;\n      var _values = witness ? Object.assign(permit, {\n        witness: witness.witness\n      }) : permit;\n      return {\n        domain: domain,\n        types: _types,\n        values: _values\n      };\n    }\n  };\n  SignatureTransfer.hash = function hash$1(permit, permit2Address, chainId, witness) {\n    var _SignatureTransfer$ge = SignatureTransfer.getPermitData(permit, permit2Address, chainId, witness),\n      domain = _SignatureTransfer$ge.domain,\n      types = _SignatureTransfer$ge.types,\n      values = _SignatureTransfer$ge.values;\n    return hash._TypedDataEncoder.hash(domain, types, values);\n  };\n  return SignatureTransfer;\n}();\nfunction validateTokenPermissions(permissions) {\n  !MaxSignatureTransferAmount.gte(permissions.amount) ? invariant(false, 'AMOUNT_OUT_OF_RANGE') : void 0;\n}\nvar Permit2Abi = [{\n  inputs: [],\n  name: \"AllowanceExpired\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"ExcessiveInvalidation\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"InsufficientAllowance\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"InvalidAmount\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"InvalidContractSignature\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"InvalidNonce\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"InvalidSignature\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"InvalidSigner\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"LengthMismatch\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NotSpender\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"SignatureExpired\",\n  type: \"error\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"owner\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"token\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"spender\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint160\",\n    name: \"amount\",\n    type: \"uint160\"\n  }, {\n    indexed: false,\n    internalType: \"uint48\",\n    name: \"expiration\",\n    type: \"uint48\"\n  }],\n  name: \"Approval\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"owner\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"token\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"spender\",\n    type: \"address\"\n  }],\n  name: \"Lockdown\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"owner\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"token\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"spender\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint48\",\n    name: \"newNonce\",\n    type: \"uint48\"\n  }, {\n    indexed: false,\n    internalType: \"uint48\",\n    name: \"oldNonce\",\n    type: \"uint48\"\n  }],\n  name: \"NonceInvalidation\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"owner\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"word\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"mask\",\n    type: \"uint256\"\n  }],\n  name: \"UnorderedNonceInvalidation\",\n  type: \"event\"\n}, {\n  inputs: [],\n  name: \"DOMAIN_SEPARATOR\",\n  outputs: [{\n    internalType: \"bytes32\",\n    name: \"\",\n    type: \"bytes32\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }],\n  name: \"allowance\",\n  outputs: [{\n    internalType: \"uint160\",\n    name: \"amount\",\n    type: \"uint160\"\n  }, {\n    internalType: \"uint48\",\n    name: \"expiration\",\n    type: \"uint48\"\n  }, {\n    internalType: \"uint48\",\n    name: \"nonce\",\n    type: \"uint48\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"token\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"spender\",\n    type: \"address\"\n  }, {\n    internalType: \"uint160\",\n    name: \"amount\",\n    type: \"uint160\"\n  }, {\n    internalType: \"uint48\",\n    name: \"expiration\",\n    type: \"uint48\"\n  }],\n  name: \"approve\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"token\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"spender\",\n    type: \"address\"\n  }, {\n    internalType: \"uint48\",\n    name: \"newNonce\",\n    type: \"uint48\"\n  }],\n  name: \"invalidateNonces\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"wordPos\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"mask\",\n    type: \"uint256\"\n  }],\n  name: \"invalidateUnorderedNonces\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      internalType: \"address\",\n      name: \"token\",\n      type: \"address\"\n    }, {\n      internalType: \"address\",\n      name: \"spender\",\n      type: \"address\"\n    }],\n    internalType: \"struct IAllowanceTransfer.TokenSpenderPair[]\",\n    name: \"approvals\",\n    type: \"tuple[]\"\n  }],\n  name: \"lockdown\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"\",\n    type: \"uint256\"\n  }],\n  name: \"nonceBitmap\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"owner\",\n    type: \"address\"\n  }, {\n    components: [{\n      components: [{\n        internalType: \"address\",\n        name: \"token\",\n        type: \"address\"\n      }, {\n        internalType: \"uint160\",\n        name: \"amount\",\n        type: \"uint160\"\n      }, {\n        internalType: \"uint48\",\n        name: \"expiration\",\n        type: \"uint48\"\n      }, {\n        internalType: \"uint48\",\n        name: \"nonce\",\n        type: \"uint48\"\n      }],\n      internalType: \"struct IAllowanceTransfer.PermitDetails[]\",\n      name: \"details\",\n      type: \"tuple[]\"\n    }, {\n      internalType: \"address\",\n      name: \"spender\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"sigDeadline\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct IAllowanceTransfer.PermitBatch\",\n    name: \"permitBatch\",\n    type: \"tuple\"\n  }, {\n    internalType: \"bytes\",\n    name: \"signature\",\n    type: \"bytes\"\n  }],\n  name: \"permit\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"owner\",\n    type: \"address\"\n  }, {\n    components: [{\n      components: [{\n        internalType: \"address\",\n        name: \"token\",\n        type: \"address\"\n      }, {\n        internalType: \"uint160\",\n        name: \"amount\",\n        type: \"uint160\"\n      }, {\n        internalType: \"uint48\",\n        name: \"expiration\",\n        type: \"uint48\"\n      }, {\n        internalType: \"uint48\",\n        name: \"nonce\",\n        type: \"uint48\"\n      }],\n      internalType: \"struct IAllowanceTransfer.PermitDetails\",\n      name: \"details\",\n      type: \"tuple\"\n    }, {\n      internalType: \"address\",\n      name: \"spender\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"sigDeadline\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct IAllowanceTransfer.PermitSingle\",\n    name: \"permitSingle\",\n    type: \"tuple\"\n  }, {\n    internalType: \"bytes\",\n    name: \"signature\",\n    type: \"bytes\"\n  }],\n  name: \"permit\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"address\",\n        name: \"token\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct ISignatureTransfer.TokenPermissions[]\",\n      name: \"permitted\",\n      type: \"tuple[]\"\n    }, {\n      internalType: \"uint256\",\n      name: \"nonce\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"deadline\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct ISignatureTransfer.PermitBatchTransferFrom\",\n    name: \"permit\",\n    type: \"tuple\"\n  }, {\n    internalType: \"address\",\n    name: \"owner\",\n    type: \"address\"\n  }, {\n    components: [{\n      internalType: \"address\",\n      name: \"to\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"requestedAmount\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct ISignatureTransfer.SignatureTransferDetails[]\",\n    name: \"transferDetails\",\n    type: \"tuple[]\"\n  }, {\n    internalType: \"bytes\",\n    name: \"signature\",\n    type: \"bytes\"\n  }],\n  name: \"permitTransferFrom\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"address\",\n        name: \"token\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct ISignatureTransfer.TokenPermissions\",\n      name: \"permitted\",\n      type: \"tuple\"\n    }, {\n      internalType: \"uint256\",\n      name: \"nonce\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"deadline\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct ISignatureTransfer.PermitTransferFrom\",\n    name: \"permit\",\n    type: \"tuple\"\n  }, {\n    internalType: \"address\",\n    name: \"owner\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"requestedAmount\",\n    type: \"uint256\"\n  }, {\n    internalType: \"bytes\",\n    name: \"signature\",\n    type: \"bytes\"\n  }],\n  name: \"permitTransferFrom\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"address\",\n        name: \"token\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct ISignatureTransfer.TokenPermissions\",\n      name: \"permitted\",\n      type: \"tuple\"\n    }, {\n      internalType: \"uint256\",\n      name: \"nonce\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"deadline\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct ISignatureTransfer.PermitTransferFrom\",\n    name: \"permit\",\n    type: \"tuple\"\n  }, {\n    internalType: \"address\",\n    name: \"owner\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"requestedAmount\",\n    type: \"uint256\"\n  }, {\n    internalType: \"bytes32\",\n    name: \"witness\",\n    type: \"bytes32\"\n  }, {\n    internalType: \"string\",\n    name: \"witnessTypeName\",\n    type: \"string\"\n  }, {\n    internalType: \"string\",\n    name: \"witnessType\",\n    type: \"string\"\n  }, {\n    internalType: \"bytes\",\n    name: \"signature\",\n    type: \"bytes\"\n  }],\n  name: \"permitWitnessTransferFrom\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"address\",\n        name: \"token\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct ISignatureTransfer.TokenPermissions[]\",\n      name: \"permitted\",\n      type: \"tuple[]\"\n    }, {\n      internalType: \"uint256\",\n      name: \"nonce\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"deadline\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct ISignatureTransfer.PermitBatchTransferFrom\",\n    name: \"permit\",\n    type: \"tuple\"\n  }, {\n    internalType: \"address\",\n    name: \"owner\",\n    type: \"address\"\n  }, {\n    components: [{\n      internalType: \"address\",\n      name: \"to\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"requestedAmount\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct ISignatureTransfer.SignatureTransferDetails[]\",\n    name: \"transferDetails\",\n    type: \"tuple[]\"\n  }, {\n    internalType: \"bytes32\",\n    name: \"witness\",\n    type: \"bytes32\"\n  }, {\n    internalType: \"string\",\n    name: \"witnessTypeName\",\n    type: \"string\"\n  }, {\n    internalType: \"string\",\n    name: \"witnessType\",\n    type: \"string\"\n  }, {\n    internalType: \"bytes\",\n    name: \"signature\",\n    type: \"bytes\"\n  }],\n  name: \"permitWitnessTransferFrom\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"token\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"from\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }, {\n    internalType: \"uint160\",\n    name: \"amount\",\n    type: \"uint160\"\n  }],\n  name: \"transferFrom\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"from\",\n    type: \"address\"\n  }, {\n    components: [{\n      internalType: \"address\",\n      name: \"token\",\n      type: \"address\"\n    }, {\n      internalType: \"uint160\",\n      name: \"amount\",\n      type: \"uint160\"\n    }, {\n      internalType: \"address\",\n      name: \"to\",\n      type: \"address\"\n    }],\n    internalType: \"struct IAllowanceTransfer.AllowanceTransferDetails[]\",\n    name: \"transferDetails\",\n    type: \"tuple[]\"\n  }],\n  name: \"transferFrom\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}];\nvar AllowanceProvider = /*#__PURE__*/function () {\n  function AllowanceProvider(provider, permit2Address) {\n    this.provider = provider;\n    this.permit2Address = permit2Address;\n    this.permit2 = new contracts.Contract(this.permit2Address, Permit2Abi, this.provider);\n  }\n  var _proto = AllowanceProvider.prototype;\n  _proto.getAllowanceData = /*#__PURE__*/function () {\n    var _getAllowanceData = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(token, owner, spender) {\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return this.permit2.allowance(owner, token, spender);\n            case 2:\n              return _context.abrupt(\"return\", _context.sent);\n            case 3:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, this);\n    }));\n    function getAllowanceData(_x, _x2, _x3) {\n      return _getAllowanceData.apply(this, arguments);\n    }\n    return getAllowanceData;\n  }();\n  _proto.getAllowance = /*#__PURE__*/function () {\n    var _getAllowance = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(token, owner, spender) {\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return this.getAllowanceData(token, owner, spender);\n            case 2:\n              return _context2.abrupt(\"return\", _context2.sent.amount);\n            case 3:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, this);\n    }));\n    function getAllowance(_x4, _x5, _x6) {\n      return _getAllowance.apply(this, arguments);\n    }\n    return getAllowance;\n  }();\n  _proto.getNonce = /*#__PURE__*/function () {\n    var _getNonce = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(token, owner, spender) {\n      return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 2;\n              return this.getAllowanceData(token, owner, spender);\n            case 2:\n              return _context3.abrupt(\"return\", _context3.sent.nonce);\n            case 3:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3, this);\n    }));\n    function getNonce(_x7, _x8, _x9) {\n      return _getNonce.apply(this, arguments);\n    }\n    return getNonce;\n  }();\n  _proto.getExpiration = /*#__PURE__*/function () {\n    var _getExpiration = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(token, owner, spender) {\n      return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              _context4.next = 2;\n              return this.getAllowanceData(token, owner, spender);\n            case 2:\n              return _context4.abrupt(\"return\", _context4.sent.expiration);\n            case 3:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4, this);\n    }));\n    function getExpiration(_x10, _x11, _x12) {\n      return _getExpiration.apply(this, arguments);\n    }\n    return getExpiration;\n  }();\n  return AllowanceProvider;\n}();\nexports.AllowanceProvider = AllowanceProvider;\nexports.AllowanceTransfer = AllowanceTransfer;\nexports.InstantExpiration = InstantExpiration;\nexports.MaxAllowanceExpiration = MaxAllowanceExpiration;\nexports.MaxAllowanceTransferAmount = MaxAllowanceTransferAmount;\nexports.MaxOrderedNonce = MaxOrderedNonce;\nexports.MaxSigDeadline = MaxSigDeadline;\nexports.MaxSignatureTransferAmount = MaxSignatureTransferAmount;\nexports.MaxUint160 = MaxUint160;\nexports.MaxUint256 = MaxUint256;\nexports.MaxUint48 = MaxUint48;\nexports.MaxUnorderedNonce = MaxUnorderedNonce;\nexports.PERMIT2_ADDRESS = PERMIT2_ADDRESS;\nexports.SignatureTransfer = SignatureTransfer;","map":{"version":3,"sources":["../src/constants.ts","../src/domain.ts","../src/allowanceTransfer.ts","../src/signatureTransfer.ts","../src/providers/AllowanceProvider.ts"],"names":["PERMIT2_ADDRESS","MaxUint48","from","MaxUint160","MaxAllowanceTransferAmount","MaxAllowanceExpiration","MaxOrderedNonce","MaxSignatureTransferAmount","MaxUint256","MaxUnorderedNonce","MaxSigDeadline","InstantExpiration","PERMIT2_DOMAIN_NAME","permit2Domain","permit2Address","chainId","PERMIT_DETAILS","type","name","PERMIT_TYPES","PermitSingle","PermitDetails","PERMIT_BATCH_TYPES","PermitBatch","isPermit","Array","AllowanceTransfer","validatePermitDetails","domain","types","values","permit","details","hash","amount","TOKEN_PERMISSIONS","PermitTransferFrom","TokenPermissions","PERMIT_BATCH_TRANSFER_FROM_TYPES","PermitBatchTransferFrom","permitTransferFromWithWitnessType","PermitWitnessTransferFrom","witnessTypeName","witness","permitBatchTransferFromWithWitnessType","PermitBatchWitnessTransferFrom","isPermitTransferFrom","SignatureTransfer","validateTokenPermissions","permissions","gte","AllowanceProvider","Contract","getAllowanceData","token","owner"],"mappings":"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","sourcesContent":["import { BigNumber } from '@ethersproject/bignumber'\n\nexport const PERMIT2_ADDRESS = '0x000000000022D473030F116dDEE9F6B43aC78BA3'\n\nexport const MaxUint48 = BigNumber.from('0xffffffffffff')\nexport const MaxUint160 = BigNumber.from('0xffffffffffffffffffffffffffffffffffffffff')\nexport const MaxUint256 = BigNumber.from('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff')\n\n// alias max types for their usages\n// allowance transfer types\nexport const MaxAllowanceTransferAmount = MaxUint160\nexport const MaxAllowanceExpiration = MaxUint48\nexport const MaxOrderedNonce = MaxUint48\n\n// signature transfer types\nexport const MaxSignatureTransferAmount = MaxUint256\nexport const MaxUnorderedNonce = MaxUint256\nexport const MaxSigDeadline = MaxUint256\n\nexport const InstantExpiration: BigNumber = BigNumber.from(0)\n","import { TypedDataDomain, TypedDataField } from '@ethersproject/abstract-signer'\n\nconst PERMIT2_DOMAIN_NAME = 'Permit2'\n\nexport function permit2Domain(permit2Address: string, chainId: number): TypedDataDomain {\n  return {\n    name: PERMIT2_DOMAIN_NAME,\n    chainId,\n    verifyingContract: permit2Address,\n  }\n}\n\nexport type PermitData = {\n  domain: TypedDataDomain\n  types: Record<string, TypedDataField[]>\n  values: any\n}\n","import invariant from 'tiny-invariant'\nimport { TypedDataDomain, TypedDataField } from '@ethersproject/abstract-signer'\nimport { BigNumberish } from '@ethersproject/bignumber'\nimport { _TypedDataEncoder } from '@ethersproject/hash'\nimport { MaxSigDeadline, MaxOrderedNonce, MaxAllowanceTransferAmount, MaxAllowanceExpiration } from './constants'\nimport { permit2Domain } from './domain'\n\nexport interface PermitDetails {\n  token: string\n  amount: BigNumberish\n  expiration: BigNumberish\n  nonce: BigNumberish\n}\n\nexport interface PermitSingle {\n  details: PermitDetails\n  spender: string\n  sigDeadline: BigNumberish\n}\n\nexport interface PermitBatch {\n  details: PermitDetails[]\n  spender: string\n  sigDeadline: BigNumberish\n}\n\nexport type PermitSingleData = {\n  domain: TypedDataDomain\n  types: Record<string, TypedDataField[]>\n  values: PermitSingle\n}\n\nexport type PermitBatchData = {\n  domain: TypedDataDomain\n  types: Record<string, TypedDataField[]>\n  values: PermitBatch\n}\n\nconst PERMIT_DETAILS = [\n  { name: 'token', type: 'address' },\n  { name: 'amount', type: 'uint160' },\n  { name: 'expiration', type: 'uint48' },\n  { name: 'nonce', type: 'uint48' },\n]\n\nconst PERMIT_TYPES = {\n  PermitSingle: [\n    { name: 'details', type: 'PermitDetails' },\n    { name: 'spender', type: 'address' },\n    { name: 'sigDeadline', type: 'uint256' },\n  ],\n  PermitDetails: PERMIT_DETAILS,\n}\n\nconst PERMIT_BATCH_TYPES = {\n  PermitBatch: [\n    { name: 'details', type: 'PermitDetails[]' },\n    { name: 'spender', type: 'address' },\n    { name: 'sigDeadline', type: 'uint256' },\n  ],\n  PermitDetails: PERMIT_DETAILS,\n}\n\nfunction isPermit(permit: PermitSingle | PermitBatch): permit is PermitSingle {\n  return !Array.isArray(permit.details)\n}\n\nexport abstract class AllowanceTransfer {\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n\n  // return the data to be sent in a eth_signTypedData RPC call\n  // for signing the given permit data\n  public static getPermitData(\n    permit: PermitSingle | PermitBatch,\n    permit2Address: string,\n    chainId: number\n  ): PermitSingleData | PermitBatchData {\n    invariant(MaxSigDeadline.gte(permit.sigDeadline), 'SIG_DEADLINE_OUT_OF_RANGE')\n\n    const domain = permit2Domain(permit2Address, chainId)\n    if (isPermit(permit)) {\n      validatePermitDetails(permit.details)\n      return {\n        domain,\n        types: PERMIT_TYPES,\n        values: permit,\n      }\n    } else {\n      permit.details.forEach(validatePermitDetails)\n      return {\n        domain,\n        types: PERMIT_BATCH_TYPES,\n        values: permit,\n      }\n    }\n  }\n\n  public static hash(permit: PermitSingle | PermitBatch, permit2Address: string, chainId: number): string {\n    const { domain, types, values } = AllowanceTransfer.getPermitData(permit, permit2Address, chainId)\n    return _TypedDataEncoder.hash(domain, types, values)\n  }\n}\n\nfunction validatePermitDetails(details: PermitDetails) {\n  invariant(MaxOrderedNonce.gte(details.nonce), 'NONCE_OUT_OF_RANGE')\n  invariant(MaxAllowanceTransferAmount.gte(details.amount), 'AMOUNT_OUT_OF_RANGE')\n  invariant(MaxAllowanceExpiration.gte(details.expiration), 'EXPIRATION_OUT_OF_RANGE')\n}\n","import invariant from 'tiny-invariant'\nimport { TypedDataDomain, TypedDataField } from '@ethersproject/abstract-signer'\nimport { BigNumberish } from '@ethersproject/bignumber'\nimport { _TypedDataEncoder } from '@ethersproject/hash'\nimport { permit2Domain } from './domain'\nimport { MaxSigDeadline, MaxUnorderedNonce, MaxSignatureTransferAmount } from './constants'\n\nexport interface Witness {\n  witness: any\n  witnessTypeName: string\n  witnessType: Record<string, TypedDataField[]>\n}\n\nexport interface TokenPermissions {\n  token: string\n  amount: BigNumberish\n}\n\nexport interface PermitTransferFrom {\n  permitted: TokenPermissions\n  spender: string\n  nonce: BigNumberish\n  deadline: BigNumberish\n}\n\nexport interface PermitBatchTransferFrom {\n  permitted: TokenPermissions[]\n  spender: string\n  nonce: BigNumberish\n  deadline: BigNumberish\n}\n\nexport type PermitTransferFromData = {\n  domain: TypedDataDomain\n  types: Record<string, TypedDataField[]>\n  values: PermitTransferFrom\n}\n\nexport type PermitBatchTransferFromData = {\n  domain: TypedDataDomain\n  types: Record<string, TypedDataField[]>\n  values: PermitBatchTransferFrom\n}\n\nconst TOKEN_PERMISSIONS = [\n  { name: 'token', type: 'address' },\n  { name: 'amount', type: 'uint256' },\n]\n\nconst PERMIT_TRANSFER_FROM_TYPES = {\n  PermitTransferFrom: [\n    { name: 'permitted', type: 'TokenPermissions' },\n    { name: 'spender', type: 'address' },\n    { name: 'nonce', type: 'uint256' },\n    { name: 'deadline', type: 'uint256' },\n  ],\n  TokenPermissions: TOKEN_PERMISSIONS,\n}\n\nconst PERMIT_BATCH_TRANSFER_FROM_TYPES = {\n  PermitBatchTransferFrom: [\n    { name: 'permitted', type: 'TokenPermissions[]' },\n    { name: 'spender', type: 'address' },\n    { name: 'nonce', type: 'uint256' },\n    { name: 'deadline', type: 'uint256' },\n  ],\n  TokenPermissions: TOKEN_PERMISSIONS,\n}\n\nfunction permitTransferFromWithWitnessType(witness: Witness): Record<string, TypedDataField[]> {\n  return {\n    PermitWitnessTransferFrom: [\n      { name: 'permitted', type: 'TokenPermissions' },\n      { name: 'spender', type: 'address' },\n      { name: 'nonce', type: 'uint256' },\n      { name: 'deadline', type: 'uint256' },\n      { name: 'witness', type: witness.witnessTypeName },\n    ],\n    TokenPermissions: TOKEN_PERMISSIONS,\n    ...witness.witnessType,\n  }\n}\n\nfunction permitBatchTransferFromWithWitnessType(witness: Witness): Record<string, TypedDataField[]> {\n  return {\n    PermitBatchWitnessTransferFrom: [\n      { name: 'permitted', type: 'TokenPermissions[]' },\n      { name: 'spender', type: 'address' },\n      { name: 'nonce', type: 'uint256' },\n      { name: 'deadline', type: 'uint256' },\n      { name: 'witness', type: witness.witnessTypeName },\n    ],\n    TokenPermissions: TOKEN_PERMISSIONS,\n    ...witness.witnessType,\n  }\n}\n\nfunction isPermitTransferFrom(permit: PermitTransferFrom | PermitBatchTransferFrom): permit is PermitTransferFrom {\n  return !Array.isArray(permit.permitted)\n}\n\nexport abstract class SignatureTransfer {\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n\n  // return the data to be sent in a eth_signTypedData RPC call\n  // for signing the given permit data\n  public static getPermitData(\n    permit: PermitTransferFrom | PermitBatchTransferFrom,\n    permit2Address: string,\n    chainId: number,\n    witness?: Witness\n  ): PermitTransferFromData | PermitBatchTransferFromData {\n    invariant(MaxSigDeadline.gte(permit.deadline), 'SIG_DEADLINE_OUT_OF_RANGE')\n    invariant(MaxUnorderedNonce.gte(permit.nonce), 'NONCE_OUT_OF_RANGE')\n\n    const domain = permit2Domain(permit2Address, chainId)\n    if (isPermitTransferFrom(permit)) {\n      validateTokenPermissions(permit.permitted)\n      const types = witness ? permitTransferFromWithWitnessType(witness) : PERMIT_TRANSFER_FROM_TYPES\n      const values = witness ? Object.assign(permit, { witness: witness.witness }) : permit\n      return {\n        domain,\n        types,\n        values,\n      }\n    } else {\n      permit.permitted.forEach(validateTokenPermissions)\n      const types = witness ? permitBatchTransferFromWithWitnessType(witness) : PERMIT_BATCH_TRANSFER_FROM_TYPES\n      const values = witness ? Object.assign(permit, { witness: witness.witness }) : permit\n      return {\n        domain,\n        types,\n        values,\n      }\n    }\n  }\n\n  public static hash(\n    permit: PermitTransferFrom | PermitBatchTransferFrom,\n    permit2Address: string,\n    chainId: number,\n    witness?: Witness\n  ): string {\n    const { domain, types, values } = SignatureTransfer.getPermitData(permit, permit2Address, chainId, witness)\n    return _TypedDataEncoder.hash(domain, types, values)\n  }\n}\n\nfunction validateTokenPermissions(permissions: TokenPermissions) {\n  invariant(MaxSignatureTransferAmount.gte(permissions.amount), 'AMOUNT_OUT_OF_RANGE')\n}\n","import { BigNumber } from '@ethersproject/bignumber'\nimport { Provider } from '@ethersproject/providers'\nimport Permit2Abi from '../../abis/Permit2.json'\nimport { Contract } from '@ethersproject/contracts'\n\nexport interface AllowanceData {\n  amount: BigNumber\n  nonce: number\n  expiration: number\n}\n\nexport class AllowanceProvider {\n  private permit2: Contract\n\n  constructor(private provider: Provider, private permit2Address: string) {\n    this.permit2 = new Contract(this.permit2Address, Permit2Abi, this.provider)\n  }\n\n  async getAllowanceData(token: string, owner: string, spender: string): Promise<AllowanceData> {\n    return await this.permit2.allowance(owner, token, spender)\n  }\n\n  async getAllowance(token: string, owner: string, spender: string): Promise<BigNumber> {\n    return (await this.getAllowanceData(token, owner, spender)).amount\n  }\n\n  async getNonce(token: string, owner: string, spender: string): Promise<number> {\n    return (await this.getAllowanceData(token, owner, spender)).nonce\n  }\n\n  async getExpiration(token: string, owner: string, spender: string): Promise<number> {\n    return (await this.getAllowanceData(token, owner, spender)).expiration\n  }\n}\n"]},"metadata":{},"sourceType":"script"}