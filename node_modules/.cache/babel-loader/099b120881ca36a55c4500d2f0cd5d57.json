{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\nvar invariant = _interopDefault(require('tiny-invariant'));\nvar UniversalRouter_json = require('@uniswap/universal-router/artifacts/contracts/UniversalRouter.sol/UniversalRouter.json');\nvar abi$7 = require('@ethersproject/abi');\nvar ethers = require('ethers');\nvar JSBI = _interopDefault(require('jsbi'));\nvar utils = require('ethers/lib/utils');\nvar v2Sdk = require('@uniswap/v2-sdk');\nvar v3Sdk = require('@uniswap/v3-sdk');\nvar routerSdk = require('@uniswap/router-sdk');\nvar sdkCore = require('@uniswap/sdk-core');\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n(function (RouterTradeType) {\n  RouterTradeType[\"UniswapTrade\"] = \"UniswapTrade\";\n  RouterTradeType[\"NFTTrade\"] = \"NFTTrade\";\n  RouterTradeType[\"UnwrapWETH\"] = \"UnwrapWETH\";\n})(exports.RouterTradeType || (exports.RouterTradeType = {}));\nvar _ABI_DEFINITION;\n/**\r\n * CommandTypes\r\n * @description Flags that modify a command's execution\r\n * @enum {number}\r\n */\nvar CommandType;\n(function (CommandType) {\n  CommandType[CommandType[\"V3_SWAP_EXACT_IN\"] = 0] = \"V3_SWAP_EXACT_IN\";\n  CommandType[CommandType[\"V3_SWAP_EXACT_OUT\"] = 1] = \"V3_SWAP_EXACT_OUT\";\n  CommandType[CommandType[\"PERMIT2_TRANSFER_FROM\"] = 2] = \"PERMIT2_TRANSFER_FROM\";\n  CommandType[CommandType[\"PERMIT2_PERMIT_BATCH\"] = 3] = \"PERMIT2_PERMIT_BATCH\";\n  CommandType[CommandType[\"SWEEP\"] = 4] = \"SWEEP\";\n  CommandType[CommandType[\"TRANSFER\"] = 5] = \"TRANSFER\";\n  CommandType[CommandType[\"PAY_PORTION\"] = 6] = \"PAY_PORTION\";\n  CommandType[CommandType[\"V2_SWAP_EXACT_IN\"] = 8] = \"V2_SWAP_EXACT_IN\";\n  CommandType[CommandType[\"V2_SWAP_EXACT_OUT\"] = 9] = \"V2_SWAP_EXACT_OUT\";\n  CommandType[CommandType[\"PERMIT\"] = 10] = \"PERMIT\";\n  CommandType[CommandType[\"WRAP_ETH\"] = 11] = \"WRAP_ETH\";\n  CommandType[CommandType[\"UNWRAP_WETH\"] = 12] = \"UNWRAP_WETH\";\n  CommandType[CommandType[\"PERMIT2_TRANSFER_FROM_BATCH\"] = 13] = \"PERMIT2_TRANSFER_FROM_BATCH\";\n  // NFT-related command types\n  CommandType[CommandType[\"SEAPORT\"] = 16] = \"SEAPORT\";\n  CommandType[CommandType[\"LOOKS_RARE_721\"] = 17] = \"LOOKS_RARE_721\";\n  CommandType[CommandType[\"NFTX\"] = 18] = \"NFTX\";\n  CommandType[CommandType[\"CRYPTOPUNKS\"] = 19] = \"CRYPTOPUNKS\";\n  CommandType[CommandType[\"LOOKS_RARE_1155\"] = 20] = \"LOOKS_RARE_1155\";\n  CommandType[CommandType[\"OWNER_CHECK_721\"] = 21] = \"OWNER_CHECK_721\";\n  CommandType[CommandType[\"OWNER_CHECK_1155\"] = 22] = \"OWNER_CHECK_1155\";\n  CommandType[CommandType[\"X2Y2_721\"] = 24] = \"X2Y2_721\";\n  CommandType[CommandType[\"SUDOSWAP\"] = 25] = \"SUDOSWAP\";\n  CommandType[CommandType[\"NFT20\"] = 26] = \"NFT20\";\n  CommandType[CommandType[\"X2Y2_1155\"] = 27] = \"X2Y2_1155\";\n  CommandType[CommandType[\"FOUNDATION\"] = 28] = \"FOUNDATION\";\n})(CommandType || (CommandType = {}));\nvar PERMIT_STRUCT = '((address token,uint160 amount,uint48 expiration,uint48 nonce) details, address spender, uint256 sigDeadline)';\nvar PERMIT_BATCH_STRUCT = '((address token,uint160 amount,uint48 expiration,uint48 nonce)[] details, address spender, uint256 sigDeadline)';\nvar ALLOW_REVERT_FLAG = 0x80;\nvar REVERTABLE_COMMANDS = /*#__PURE__*/new Set([CommandType.SEAPORT, CommandType.NFTX, CommandType.LOOKS_RARE_721, CommandType.LOOKS_RARE_1155, CommandType.X2Y2_721, CommandType.X2Y2_1155, CommandType.FOUNDATION, CommandType.SUDOSWAP, CommandType.NFT20, CommandType.CRYPTOPUNKS]);\nvar ABI_DEFINITION = (_ABI_DEFINITION = {}, _ABI_DEFINITION[CommandType.PERMIT] = [PERMIT_STRUCT, 'bytes'], _ABI_DEFINITION[CommandType.PERMIT2_PERMIT_BATCH] = [PERMIT_BATCH_STRUCT, 'bytes'], _ABI_DEFINITION[CommandType.PERMIT2_TRANSFER_FROM] = ['address', 'address', 'uint160'], _ABI_DEFINITION[CommandType.PERMIT2_TRANSFER_FROM_BATCH] = ['bytes'], _ABI_DEFINITION[CommandType.TRANSFER] = ['address', 'address', 'uint256'], _ABI_DEFINITION[CommandType.V3_SWAP_EXACT_IN] = ['address', 'uint256', 'uint256', 'bytes', 'bool'], _ABI_DEFINITION[CommandType.V3_SWAP_EXACT_OUT] = ['address', 'uint256', 'uint256', 'bytes', 'bool'], _ABI_DEFINITION[CommandType.V2_SWAP_EXACT_IN] = ['address', 'uint256', 'uint256', 'address[]', 'bool'], _ABI_DEFINITION[CommandType.V2_SWAP_EXACT_OUT] = ['address', 'uint256', 'uint256', 'address[]', 'bool'], _ABI_DEFINITION[CommandType.SEAPORT] = ['uint256', 'bytes'], _ABI_DEFINITION[CommandType.WRAP_ETH] = ['address', 'uint256'], _ABI_DEFINITION[CommandType.UNWRAP_WETH] = ['address', 'uint256'], _ABI_DEFINITION[CommandType.SWEEP] = ['address', 'address', 'uint256'], _ABI_DEFINITION[CommandType.NFTX] = ['uint256', 'bytes'], _ABI_DEFINITION[CommandType.LOOKS_RARE_721] = ['uint256', 'bytes', 'address', 'address', 'uint256'], _ABI_DEFINITION[CommandType.LOOKS_RARE_1155] = ['uint256', 'bytes', 'address', 'address', 'uint256', 'uint256'], _ABI_DEFINITION[CommandType.X2Y2_721] = ['uint256', 'bytes', 'address', 'address', 'uint256'], _ABI_DEFINITION[CommandType.X2Y2_1155] = ['uint256', 'bytes', 'address', 'address', 'uint256', 'uint256'], _ABI_DEFINITION[CommandType.FOUNDATION] = ['uint256', 'bytes', 'address', 'address', 'uint256'], _ABI_DEFINITION[CommandType.PAY_PORTION] = ['address', 'address', 'uint256'], _ABI_DEFINITION[CommandType.SUDOSWAP] = ['uint256', 'bytes'], _ABI_DEFINITION[CommandType.OWNER_CHECK_721] = ['address', 'address', 'uint256'], _ABI_DEFINITION[CommandType.OWNER_CHECK_1155] = ['address', 'address', 'uint256', 'uint256'], _ABI_DEFINITION[CommandType.NFT20] = ['uint256', 'bytes'], _ABI_DEFINITION[CommandType.CRYPTOPUNKS] = ['uint256', 'address', 'uint256'], _ABI_DEFINITION);\nvar RoutePlanner = /*#__PURE__*/function () {\n  function RoutePlanner() {\n    this.commands = '0x';\n    this.inputs = [];\n  }\n  var _proto = RoutePlanner.prototype;\n  _proto.addCommand = function addCommand(type, parameters, allowRevert) {\n    if (allowRevert === void 0) {\n      allowRevert = false;\n    }\n    var command = createCommand(type, parameters);\n    this.inputs.push(command.encodedInput);\n    if (allowRevert) {\n      if (!REVERTABLE_COMMANDS.has(command.type)) {\n        throw new Error(\"command type: \" + command.type + \" cannot be allowed to revert\");\n      }\n      command.type = command.type | ALLOW_REVERT_FLAG;\n    }\n    this.commands = this.commands.concat(command.type.toString(16).padStart(2, '0'));\n  };\n  return RoutePlanner;\n}();\nfunction createCommand(type, parameters) {\n  var encodedInput = utils.defaultAbiCoder.encode(ABI_DEFINITION[type], parameters);\n  return {\n    type: type,\n    encodedInput: encodedInput\n  };\n}\nvar UNIVERSAL_ROUTER_ADDRESS = function UNIVERSAL_ROUTER_ADDRESS(chainId) {\n  switch (chainId) {\n    case 1:\n      // mainnet\n      return '0xEf1c6E67703c7BD7107eed8303Fbe6EC2554BF6B';\n    case 5:\n      // goerli\n      return '0x4648a43B2C14Da09FdF82B161150d3F634f40491';\n    case 137:\n      // polygon\n      return '0x4C60051384bd2d3C01bfc845Cf5F4b44bcbE9de5';\n    case 80001:\n      // polygon mumbai\n      return '0x4648a43B2C14Da09FdF82B161150d3F634f40491';\n    case 10:\n      // optimism\n      return '0xb555edF5dcF85f42cEeF1f3630a52A108E55A654';\n    case 420:\n      // optimism goerli\n      return '0x4648a43B2C14Da09FdF82B161150d3F634f40491';\n    case 42161:\n      // arbitrum\n      return '0x4C60051384bd2d3C01bfc845Cf5F4b44bcbE9de5';\n    case 421613:\n      // arbitrum goerli\n      return '0x4648a43B2C14Da09FdF82B161150d3F634f40491';\n    case 42220:\n      // celo\n      return '0xC73d61d192FB994157168Fb56730FdEc64C9Cb8F';\n    case 44787:\n      // celo alfajores\n      return '0x4648a43B2C14Da09FdF82B161150d3F634f40491';\n    case 56:\n      // binance smart chain\n      return '0x5Dc88340E1c5c6366864Ee415d6034cadd1A9897';\n    default:\n      throw new Error(\"Universal Router not deployed on chain \" + chainId);\n  }\n};\nvar WETH_ADDRESS = function WETH_ADDRESS(chainId) {\n  switch (chainId) {\n    case 1:\n      //mainnet\n      return '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2';\n    case 5:\n      // goerli\n      return '0xb4fbf271143f4fbf7b91a5ded31805e42b2208d6';\n    case 137:\n      // polygon\n      return '0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270';\n    case 80001:\n      // polygon mumbai\n      return '0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889';\n    case 10:\n      // optimism\n      return '0x4200000000000000000000000000000000000006';\n    case 420:\n      // optimism goerli\n      return '0x4200000000000000000000000000000000000006';\n    case 42161:\n      // arbitrum\n      return '0x82aF49447D8a07e3bd95BD0d56f35241523fBab1';\n    case 421613:\n      // arbitrum goerli\n      return '0xe39Ab88f8A4777030A534146A9Ca3B52bd5D43A3';\n    case 56:\n      // binance smart chain\n      return '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c';\n    default:\n      throw new Error(\"WETH9 or UniversalRouter not deployed on chain \" + chainId);\n  }\n};\nvar PERMIT2_ADDRESS = '0x000000000022D473030F116dDEE9F6B43aC78BA3';\nvar CONTRACT_BALANCE = /*#__PURE__*/ethers.BigNumber.from(2).pow(255);\nvar ETH_ADDRESS = '0x0000000000000000000000000000000000000000';\nvar SENDER_AS_RECIPIENT = '0x0000000000000000000000000000000000000001';\nvar ROUTER_AS_RECIPIENT = '0x0000000000000000000000000000000000000002';\nvar REFUND_ETH_PRICE_IMPACT_THRESHOLD = /*#__PURE__*/new sdkCore.Percent( /*#__PURE__*/JSBI.BigInt(50), /*#__PURE__*/JSBI.BigInt(100));\n// Wrapper for uniswap router-sdk trade entity to encode swaps for Universal Router\n// also translates trade objects from previous (v2, v3) SDKs\nvar UniswapTrade = /*#__PURE__*/function () {\n  function UniswapTrade(trade, options) {\n    this.trade = trade;\n    this.options = options;\n    this.tradeType = exports.RouterTradeType.UniswapTrade;\n  }\n  var _proto = UniswapTrade.prototype;\n  _proto.encode = function encode(planner, _config) {\n    var _this$options$recipie;\n    var payerIsUser = true;\n    if (this.trade.inputAmount.currency.isNative) {\n      // TODO: optimize if only one v2 pool we can directly send this to the pool\n      planner.addCommand(CommandType.WRAP_ETH, [ROUTER_AS_RECIPIENT, this.trade.maximumAmountIn(this.options.slippageTolerance).quotient.toString()]);\n      // since WETH is now owned by the router, the router pays for inputs\n      payerIsUser = false;\n    }\n    this.options.recipient = (_this$options$recipie = this.options.recipient) != null ? _this$options$recipie : SENDER_AS_RECIPIENT;\n    // flag for whether we want to perform slippage check on aggregate output of multiple routes\n    //   1. when there are >2 exact input trades. this is only a heuristic,\n    //      as it's still more gas-expensive even in this case, but has benefits\n    //      in that the reversion probability is lower\n    var performAggregatedSlippageCheck = this.trade.tradeType === sdkCore.TradeType.EXACT_INPUT && this.trade.routes.length > 2;\n    var outputIsNative = this.trade.outputAmount.currency.isNative;\n    var inputIsNative = this.trade.inputAmount.currency.isNative;\n    var routerMustCustody = performAggregatedSlippageCheck || outputIsNative;\n    for (var _iterator = _createForOfIteratorHelperLoose(this.trade.swaps), _step; !(_step = _iterator()).done;) {\n      var swap = _step.value;\n      switch (swap.route.protocol) {\n        case routerSdk.Protocol.V2:\n          addV2Swap(planner, swap, this.trade.tradeType, this.options, payerIsUser, routerMustCustody);\n          break;\n        case routerSdk.Protocol.V3:\n          addV3Swap(planner, swap, this.trade.tradeType, this.options, payerIsUser, routerMustCustody);\n          break;\n        case routerSdk.Protocol.MIXED:\n          addMixedSwap(planner, swap, this.trade.tradeType, this.options, payerIsUser, routerMustCustody);\n          break;\n        default:\n          throw new Error('UNSUPPORTED_TRADE_PROTOCOL');\n      }\n    }\n    if (routerMustCustody) {\n      if (outputIsNative) {\n        planner.addCommand(CommandType.UNWRAP_WETH, [this.options.recipient, this.trade.minimumAmountOut(this.options.slippageTolerance).quotient.toString()]);\n      } else {\n        planner.addCommand(CommandType.SWEEP, [this.trade.outputAmount.currency.wrapped.address, this.options.recipient, this.trade.minimumAmountOut(this.options.slippageTolerance).quotient.toString()]);\n      }\n    }\n    if (inputIsNative && (this.trade.tradeType === sdkCore.TradeType.EXACT_OUTPUT || riskOfPartialFill(this.trade))) {\n      // for exactOutput swaps that take native currency as input\n      // we need to send back the change to the user\n      planner.addCommand(CommandType.UNWRAP_WETH, [this.options.recipient, 0]);\n    }\n  };\n  return UniswapTrade;\n}();\n// encode a uniswap v2 swap\nfunction addV2Swap(planner, _ref, tradeType, options, payerIsUser, routerMustCustody) {\n  var route = _ref.route,\n    inputAmount = _ref.inputAmount,\n    outputAmount = _ref.outputAmount;\n  var trade = new v2Sdk.Trade(route, tradeType == sdkCore.TradeType.EXACT_INPUT ? inputAmount : outputAmount, tradeType);\n  if (tradeType == sdkCore.TradeType.EXACT_INPUT) {\n    planner.addCommand(CommandType.V2_SWAP_EXACT_IN, [\n    // if native, we have to unwrap so keep in the router for now\n    routerMustCustody ? ROUTER_AS_RECIPIENT : options.recipient, trade.maximumAmountIn(options.slippageTolerance).quotient.toString(), trade.minimumAmountOut(options.slippageTolerance).quotient.toString(), route.path.map(function (pool) {\n      return pool.address;\n    }), payerIsUser]);\n  } else if (tradeType == sdkCore.TradeType.EXACT_OUTPUT) {\n    planner.addCommand(CommandType.V2_SWAP_EXACT_OUT, [routerMustCustody ? ROUTER_AS_RECIPIENT : options.recipient, trade.minimumAmountOut(options.slippageTolerance).quotient.toString(), trade.maximumAmountIn(options.slippageTolerance).quotient.toString(), route.path.map(function (pool) {\n      return pool.address;\n    }), payerIsUser]);\n  }\n}\n// encode a uniswap v3 swap\nfunction addV3Swap(planner, _ref2, tradeType, options, payerIsUser, routerMustCustody) {\n  var route = _ref2.route,\n    inputAmount = _ref2.inputAmount,\n    outputAmount = _ref2.outputAmount;\n  var trade = v3Sdk.Trade.createUncheckedTrade({\n    route: route,\n    inputAmount: inputAmount,\n    outputAmount: outputAmount,\n    tradeType: tradeType\n  });\n  var path = v3Sdk.encodeRouteToPath(route, trade.tradeType === sdkCore.TradeType.EXACT_OUTPUT);\n  if (tradeType == sdkCore.TradeType.EXACT_INPUT) {\n    planner.addCommand(CommandType.V3_SWAP_EXACT_IN, [routerMustCustody ? ROUTER_AS_RECIPIENT : options.recipient, trade.maximumAmountIn(options.slippageTolerance).quotient.toString(), trade.minimumAmountOut(options.slippageTolerance).quotient.toString(), path, payerIsUser]);\n  } else if (tradeType == sdkCore.TradeType.EXACT_OUTPUT) {\n    planner.addCommand(CommandType.V3_SWAP_EXACT_OUT, [routerMustCustody ? ROUTER_AS_RECIPIENT : options.recipient, trade.minimumAmountOut(options.slippageTolerance).quotient.toString(), trade.maximumAmountIn(options.slippageTolerance).quotient.toString(), path, payerIsUser]);\n  }\n}\n// encode a mixed route swap, i.e. including both v2 and v3 pools\nfunction addMixedSwap(planner, swap, tradeType, options, payerIsUser, routerMustCustody) {\n  var route = swap.route,\n    inputAmount = swap.inputAmount,\n    outputAmount = swap.outputAmount;\n  var tradeRecipient = routerMustCustody ? ROUTER_AS_RECIPIENT : options.recipient;\n  // single hop, so it can be reduced to plain v2 or v3 swap logic\n  if (route.pools.length === 1) {\n    if (route.pools[0] instanceof v3Sdk.Pool) {\n      return addV3Swap(planner, swap, tradeType, options, payerIsUser, routerMustCustody);\n    } else if (route.pools[0] instanceof v2Sdk.Pair) {\n      return addV2Swap(planner, swap, tradeType, options, payerIsUser, routerMustCustody);\n    } else {\n      throw new Error('Invalid route type');\n    }\n  }\n  var trade = routerSdk.MixedRouteTrade.createUncheckedTrade({\n    route: route,\n    inputAmount: inputAmount,\n    outputAmount: outputAmount,\n    tradeType: tradeType\n  });\n  var amountIn = trade.maximumAmountIn(options.slippageTolerance, inputAmount).quotient.toString();\n  var amountOut = trade.minimumAmountOut(options.slippageTolerance, outputAmount).quotient.toString();\n  // logic from\n  // https://github.com/Uniswap/router-sdk/blob/d8eed164e6c79519983844ca8b6a3fc24ebcb8f8/src/swapRouter.ts#L276\n  var sections = routerSdk.partitionMixedRouteByProtocol(route);\n  var isLastSectionInRoute = function isLastSectionInRoute(i) {\n    return i === sections.length - 1;\n  };\n  var outputToken;\n  var inputToken = route.input.wrapped;\n  for (var i = 0; i < sections.length; i++) {\n    var section = sections[i];\n    /// Now, we get output of this section\n    outputToken = routerSdk.getOutputOfPools(section, inputToken);\n    var newRouteOriginal = new routerSdk.MixedRouteSDK([].concat(section), section[0].token0.equals(inputToken) ? section[0].token0 : section[0].token1, outputToken);\n    var newRoute = new routerSdk.MixedRoute(newRouteOriginal);\n    /// Previous output is now input\n    inputToken = outputToken;\n    var mixedRouteIsAllV3 = function mixedRouteIsAllV3(route) {\n      return route.pools.every(function (pool) {\n        return pool instanceof v3Sdk.Pool;\n      });\n    };\n    if (mixedRouteIsAllV3(newRoute)) {\n      var path = routerSdk.encodeMixedRouteToPath(newRoute);\n      planner.addCommand(CommandType.V3_SWAP_EXACT_IN, [\n      // if not last section: send tokens directly to the first v2 pair of the next section\n      // note: because of the partitioning function we can be sure that the next section is v2\n      isLastSectionInRoute(i) ? tradeRecipient : sections[i + 1][0].liquidityToken.address, i == 0 ? amountIn : CONTRACT_BALANCE, !isLastSectionInRoute(i) ? 0 : amountOut, path, payerIsUser && i === 0]);\n    } else {\n      planner.addCommand(CommandType.V2_SWAP_EXACT_IN, [isLastSectionInRoute(i) ? tradeRecipient : ROUTER_AS_RECIPIENT, i === 0 ? amountIn : CONTRACT_BALANCE, !isLastSectionInRoute(i) ? 0 : amountOut, newRoute.path.map(function (pool) {\n        return pool.address;\n      }), payerIsUser && i === 0]);\n    }\n  }\n}\n// if price impact is very high, there's a chance of hitting max/min prices resulting in a partial fill of the swap\nfunction riskOfPartialFill(trade) {\n  return trade.priceImpact.greaterThan(REFUND_ETH_PRICE_IMPACT_THRESHOLD);\n}\nvar SIGNATURE_LENGTH = 65;\nvar EIP_2098_SIGNATURE_LENGTH = 64;\nfunction encodePermit(planner, permit) {\n  var signature = permit.signature;\n  var length = ethers.ethers.utils.arrayify(permit.signature).length;\n  // signature data provided for EIP-1271 may have length different from ECDSA signature\n  if (length === SIGNATURE_LENGTH || length === EIP_2098_SIGNATURE_LENGTH) {\n    // sanitizes signature to cover edge cases of malformed EIP-2098 sigs and v used as recovery id\n    signature = ethers.ethers.utils.joinSignature(ethers.ethers.utils.splitSignature(permit.signature));\n  }\n  planner.addCommand(CommandType.PERMIT, [permit, signature]);\n}\nvar SwapRouter = /*#__PURE__*/function () {\n  function SwapRouter() {}\n  SwapRouter.swapCallParameters = function swapCallParameters(trades, config) {\n    if (config === void 0) {\n      config = {};\n    }\n    if (!Array.isArray(trades)) trades = [trades];\n    var nftTrades = trades.filter(function (trade, _, _ref) {\n      return trade.hasOwnProperty('market');\n    });\n    var allowRevert = nftTrades.length == 1 && nftTrades[0].orders.length == 1 ? false : true;\n    var planner = new RoutePlanner();\n    // track value flow to require the right amount of native value\n    var currentNativeValueInRouter = ethers.BigNumber.from(0);\n    var transactionValue = ethers.BigNumber.from(0);\n    for (var _iterator = _createForOfIteratorHelperLoose(trades), _step; !(_step = _iterator()).done;) {\n      var trade = _step.value;\n      /**\r\n       * is NFTTrade\r\n       */\n      if (trade.tradeType == exports.RouterTradeType.NFTTrade) {\n        var nftTrade = trade;\n        nftTrade.encode(planner, {\n          allowRevert: allowRevert\n        });\n        var tradePrice = nftTrade.getTotalPrice();\n        // send enough native value to contract for NFT purchase\n        if (currentNativeValueInRouter.lt(tradePrice)) {\n          transactionValue = transactionValue.add(tradePrice.sub(currentNativeValueInRouter));\n          currentNativeValueInRouter = ethers.BigNumber.from(0);\n        } else {\n          currentNativeValueInRouter = currentNativeValueInRouter.sub(tradePrice);\n        }\n        /**\r\n         * is Uniswap Trade\r\n         */\n      } else if (trade.tradeType == exports.RouterTradeType.UniswapTrade) {\n        var uniswapTrade = trade;\n        var inputIsNative = uniswapTrade.trade.inputAmount.currency.isNative;\n        var outputIsNative = uniswapTrade.trade.outputAmount.currency.isNative;\n        var swapOptions = uniswapTrade.options;\n        !!(inputIsNative && !!swapOptions.inputTokenPermit) ? invariant(false, 'NATIVE_INPUT_PERMIT') : void 0;\n        if (!!swapOptions.inputTokenPermit) {\n          encodePermit(planner, swapOptions.inputTokenPermit);\n        }\n        if (inputIsNative) {\n          transactionValue = transactionValue.add(ethers.BigNumber.from(uniswapTrade.trade.maximumAmountIn(swapOptions.slippageTolerance).quotient.toString()));\n        }\n        // track amount of native currency in the router\n        if (outputIsNative && swapOptions.recipient == ROUTER_AS_RECIPIENT) {\n          currentNativeValueInRouter = currentNativeValueInRouter.add(ethers.BigNumber.from(uniswapTrade.trade.minimumAmountOut(swapOptions.slippageTolerance).quotient.toString()));\n        }\n        uniswapTrade.encode(planner, {\n          allowRevert: false\n        });\n        /**\r\n         * is UnwrapWETH\r\n         */\n      } else if (trade.tradeType == exports.RouterTradeType.UnwrapWETH) {\n        var UnwrapWETH = trade;\n        trade.encode(planner, {\n          allowRevert: false\n        });\n        currentNativeValueInRouter = currentNativeValueInRouter.add(UnwrapWETH.amount);\n        /**\r\n         * else\r\n         */\n      } else {\n        throw 'trade must be of instance: UniswapTrade or NFTTrade';\n      }\n    }\n    // TODO: matches current logic for now, but should eventually only sweep for multiple NFT trades\n    // or NFT trades with potential slippage (i.e. sudo)\n    if (nftTrades.length > 0) planner.addCommand(CommandType.SWEEP, [ETH_ADDRESS, SENDER_AS_RECIPIENT, 0]);\n    return SwapRouter.encodePlan(planner, transactionValue, config);\n  }\n  /**\r\n   * @deprecated in favor of swapCallParameters. Update before next major version 2.0.0\r\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given swap.\r\n   * @param trades to produce call parameters for\r\n   */;\n  SwapRouter.swapNFTCallParameters = function swapNFTCallParameters(trades, config) {\n    if (config === void 0) {\n      config = {};\n    }\n    var planner = new RoutePlanner();\n    var totalPrice = ethers.BigNumber.from(0);\n    var allowRevert = trades.length == 1 && trades[0].orders.length == 1 ? false : true;\n    for (var _iterator2 = _createForOfIteratorHelperLoose(trades), _step2; !(_step2 = _iterator2()).done;) {\n      var trade = _step2.value;\n      trade.encode(planner, {\n        allowRevert: allowRevert\n      });\n      totalPrice = totalPrice.add(trade.getTotalPrice());\n    }\n    planner.addCommand(CommandType.SWEEP, [ETH_ADDRESS, SENDER_AS_RECIPIENT, 0]);\n    return SwapRouter.encodePlan(planner, totalPrice, config);\n  }\n  /**\r\n   * @deprecated in favor of swapCallParameters. Update before next major version 2.0.0\r\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\r\n   * @param trades to produce call parameters for\r\n   * @param options options for the call parameters\r\n   */;\n  SwapRouter.swapERC20CallParameters = function swapERC20CallParameters(trades, options) {\n    // TODO: use permit if signature included in swapOptions\n    var planner = new RoutePlanner();\n    var trade = new UniswapTrade(trades, options);\n    var inputCurrency = trade.trade.inputAmount.currency;\n    !!(inputCurrency.isNative && !!options.inputTokenPermit) ? invariant(false, 'NATIVE_INPUT_PERMIT') : void 0;\n    if (options.inputTokenPermit) {\n      encodePermit(planner, options.inputTokenPermit);\n    }\n    var nativeCurrencyValue = inputCurrency.isNative ? ethers.BigNumber.from(trade.trade.maximumAmountIn(options.slippageTolerance).quotient.toString()) : ethers.BigNumber.from(0);\n    trade.encode(planner, {\n      allowRevert: false\n    });\n    return SwapRouter.encodePlan(planner, nativeCurrencyValue, {\n      deadline: options.deadlineOrPreviousBlockhash ? ethers.BigNumber.from(options.deadlineOrPreviousBlockhash) : undefined\n    });\n  }\n  /**\r\n   * Encodes a planned route into a method name and parameters for the Router contract.\r\n   * @param planner the planned route\r\n   * @param nativeCurrencyValue the native currency value of the planned route\r\n   * @param config the router config\r\n   */;\n  SwapRouter.encodePlan = function encodePlan(planner, nativeCurrencyValue, config) {\n    if (config === void 0) {\n      config = {};\n    }\n    var commands = planner.commands,\n      inputs = planner.inputs;\n    var functionSignature = !!config.deadline ? 'execute(bytes,bytes[],uint256)' : 'execute(bytes,bytes[])';\n    var parameters = !!config.deadline ? [commands, inputs, config.deadline] : [commands, inputs];\n    var calldata = SwapRouter.INTERFACE.encodeFunctionData(functionSignature, parameters);\n    return {\n      calldata: calldata,\n      value: nativeCurrencyValue.toHexString()\n    };\n  };\n  return SwapRouter;\n}();\nSwapRouter.INTERFACE = /*#__PURE__*/new abi$7.Interface(UniversalRouter_json.abi);\nvar NFTTrade = function NFTTrade(market, orders) {\n  this.tradeType = exports.RouterTradeType.NFTTrade;\n  !(orders.length > 0) ? invariant(false, 'no buy Items') : void 0;\n  this.market = market;\n  this.orders = orders;\n};\n(function (Market) {\n  Market[\"Foundation\"] = \"foundation\";\n  Market[\"LooksRare\"] = \"looksrare\";\n  Market[\"NFT20\"] = \"nft20\";\n  Market[\"NFTX\"] = \"nftx\";\n  Market[\"Seaport\"] = \"seaport\";\n  Market[\"Sudoswap\"] = \"Sudoswap\";\n  Market[\"Cryptopunks\"] = \"cryptopunks\";\n  Market[\"X2Y2\"] = \"x2y2\";\n})(exports.Market || (exports.Market = {}));\n(function (TokenType) {\n  TokenType[\"ERC721\"] = \"ERC721\";\n  TokenType[\"ERC1155\"] = \"ERC1155\";\n  TokenType[\"Cryptopunk\"] = \"Cryptopunk\";\n})(exports.TokenType || (exports.TokenType = {}));\nvar CryptopunkTrade = /*#__PURE__*/function (_NFTTrade) {\n  _inheritsLoose(CryptopunkTrade, _NFTTrade);\n  function CryptopunkTrade(orders) {\n    return _NFTTrade.call(this, exports.Market.Cryptopunks, orders) || this;\n  }\n  var _proto = CryptopunkTrade.prototype;\n  _proto.encode = function encode(planner, config) {\n    for (var _iterator = _createForOfIteratorHelperLoose(this.orders), _step; !(_step = _iterator()).done;) {\n      var item = _step.value;\n      planner.addCommand(CommandType.CRYPTOPUNKS, [item.tokenId, item.recipient, item.value], config.allowRevert);\n    }\n  };\n  _proto.getBuyItems = function getBuyItems() {\n    var buyItems = [];\n    for (var _iterator2 = _createForOfIteratorHelperLoose(this.orders), _step2; !(_step2 = _iterator2()).done;) {\n      var item = _step2.value;\n      buyItems.push({\n        tokenAddress: CryptopunkTrade.CRYPTOPUNK_ADDRESS,\n        tokenId: item.tokenId,\n        tokenType: exports.TokenType.Cryptopunk\n      });\n    }\n    return buyItems;\n  };\n  _proto.getTotalPrice = function getTotalPrice() {\n    var total = ethers.BigNumber.from(0);\n    for (var _iterator3 = _createForOfIteratorHelperLoose(this.orders), _step3; !(_step3 = _iterator3()).done;) {\n      var item = _step3.value;\n      total = total.add(item.value);\n    }\n    return total;\n  };\n  return CryptopunkTrade;\n}(NFTTrade);\nCryptopunkTrade.CRYPTOPUNK_ADDRESS = '0xb47e3cd837ddf8e4c57f05d70ab865de6e193bbb';\nvar abi = [{\n  inputs: [{\n    internalType: \"address payable\",\n    name: \"treasury\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"feth\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"royaltyRegistry\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"duration\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"constructor\"\n}, {\n  inputs: [],\n  name: \"FoundationTreasuryNode_Address_Is_Not_A_Contract\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"FoundationTreasuryNode_Caller_Not_Admin\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"buyPrice\",\n    type: \"uint256\"\n  }],\n  name: \"NFTMarketBuyPrice_Cannot_Buy_At_Lower_Price\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketBuyPrice_Cannot_Buy_Unset_Price\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketBuyPrice_Cannot_Cancel_Unset_Price\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"owner\",\n    type: \"address\"\n  }],\n  name: \"NFTMarketBuyPrice_Only_Owner_Can_Cancel_Price\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"owner\",\n    type: \"address\"\n  }],\n  name: \"NFTMarketBuyPrice_Only_Owner_Can_Set_Price\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketBuyPrice_Price_Already_Set\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketBuyPrice_Price_Too_High\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"seller\",\n    type: \"address\"\n  }],\n  name: \"NFTMarketBuyPrice_Seller_Mismatch\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketCore_FETH_Address_Is_Not_A_Contract\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketCore_Only_FETH_Can_Transfer_ETH\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketCore_Seller_Not_Found\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketFees_Address_Does_Not_Support_IRoyaltyRegistry\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketOffer_Cannot_Be_Made_While_In_Auction\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"currentOfferAmount\",\n    type: \"uint256\"\n  }],\n  name: \"NFTMarketOffer_Offer_Below_Min_Amount\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"expiry\",\n    type: \"uint256\"\n  }],\n  name: \"NFTMarketOffer_Offer_Expired\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"currentOfferFrom\",\n    type: \"address\"\n  }],\n  name: \"NFTMarketOffer_Offer_From_Does_Not_Match\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"minOfferAmount\",\n    type: \"uint256\"\n  }],\n  name: \"NFTMarketOffer_Offer_Must_Be_At_Least_Min_Amount\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketOffer_Provided_Contract_And_TokenId_Count_Must_Match\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketOffer_Reason_Required\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }],\n  name: \"NFTMarketReserveAuction_Already_Listed\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"minAmount\",\n    type: \"uint256\"\n  }],\n  name: \"NFTMarketReserveAuction_Bid_Must_Be_At_Least_Min_Amount\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketReserveAuction_Cannot_Admin_Cancel_Without_Reason\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"reservePrice\",\n    type: \"uint256\"\n  }],\n  name: \"NFTMarketReserveAuction_Cannot_Bid_Lower_Than_Reserve_Price\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"endTime\",\n    type: \"uint256\"\n  }],\n  name: \"NFTMarketReserveAuction_Cannot_Bid_On_Ended_Auction\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketReserveAuction_Cannot_Bid_On_Nonexistent_Auction\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketReserveAuction_Cannot_Cancel_Nonexistent_Auction\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketReserveAuction_Cannot_Finalize_Already_Settled_Auction\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"endTime\",\n    type: \"uint256\"\n  }],\n  name: \"NFTMarketReserveAuction_Cannot_Finalize_Auction_In_Progress\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketReserveAuction_Cannot_Rebid_Over_Outstanding_Bid\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"maxDuration\",\n    type: \"uint256\"\n  }],\n  name: \"NFTMarketReserveAuction_Exceeds_Max_Duration\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"extensionDuration\",\n    type: \"uint256\"\n  }],\n  name: \"NFTMarketReserveAuction_Less_Than_Extension_Duration\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketReserveAuction_Must_Set_Non_Zero_Reserve_Price\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"seller\",\n    type: \"address\"\n  }],\n  name: \"NFTMarketReserveAuction_Not_Matching_Seller\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"owner\",\n    type: \"address\"\n  }],\n  name: \"NFTMarketReserveAuction_Only_Owner_Can_Update_Auction\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketReserveAuction_Price_Already_Set\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketReserveAuction_Too_Much_Value_Provided\",\n  type: \"error\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"seller\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"buyer\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"protocolFee\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"creatorFee\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"sellerRev\",\n    type: \"uint256\"\n  }],\n  name: \"BuyPriceAccepted\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }],\n  name: \"BuyPriceCanceled\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }],\n  name: \"BuyPriceInvalidated\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"seller\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"price\",\n    type: \"uint256\"\n  }],\n  name: \"BuyPriceSet\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"buyReferrer\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"buyReferrerProtocolFee\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"buyReferrerSellerFee\",\n    type: \"uint256\"\n  }],\n  name: \"BuyReferralPaid\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"uint8\",\n    name: \"version\",\n    type: \"uint8\"\n  }],\n  name: \"Initialized\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"buyer\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"seller\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"protocolFee\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"creatorFee\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"sellerRev\",\n    type: \"uint256\"\n  }],\n  name: \"OfferAccepted\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"string\",\n    name: \"reason\",\n    type: \"string\"\n  }],\n  name: \"OfferCanceledByAdmin\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }],\n  name: \"OfferInvalidated\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"buyer\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"expiration\",\n    type: \"uint256\"\n  }],\n  name: \"OfferMade\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"bidder\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"endTime\",\n    type: \"uint256\"\n  }],\n  name: \"ReserveAuctionBidPlaced\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }],\n  name: \"ReserveAuctionCanceled\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"string\",\n    name: \"reason\",\n    type: \"string\"\n  }],\n  name: \"ReserveAuctionCanceledByAdmin\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"seller\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"duration\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"extensionDuration\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"reservePrice\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }],\n  name: \"ReserveAuctionCreated\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"seller\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"bidder\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"protocolFee\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"creatorFee\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"sellerRev\",\n    type: \"uint256\"\n  }],\n  name: \"ReserveAuctionFinalized\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }],\n  name: \"ReserveAuctionInvalidated\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"reservePrice\",\n    type: \"uint256\"\n  }],\n  name: \"ReserveAuctionUpdated\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"user\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }],\n  name: \"WithdrawalToFETH\",\n  type: \"event\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address\",\n    name: \"offerFrom\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"minAmount\",\n    type: \"uint256\"\n  }],\n  name: \"acceptOffer\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address[]\",\n    name: \"nftContracts\",\n    type: \"address[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"tokenIds\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"string\",\n    name: \"reason\",\n    type: \"string\"\n  }],\n  name: \"adminCancelOffers\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"string\",\n    name: \"reason\",\n    type: \"string\"\n  }],\n  name: \"adminCancelReserveAuction\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"maxPrice\",\n    type: \"uint256\"\n  }],\n  name: \"buy\",\n  outputs: [],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"maxPrice\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address payable\",\n    name: \"referrer\",\n    type: \"address\"\n  }],\n  name: \"buyV2\",\n  outputs: [],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }],\n  name: \"cancelBuyPrice\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }],\n  name: \"cancelReserveAuction\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"reservePrice\",\n    type: \"uint256\"\n  }],\n  name: \"createReserveAuction\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }],\n  name: \"finalizeReserveAuction\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }],\n  name: \"getBuyPrice\",\n  outputs: [{\n    internalType: \"address\",\n    name: \"seller\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"price\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"price\",\n    type: \"uint256\"\n  }],\n  name: \"getFeesAndRecipients\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"protocolFee\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"creatorRev\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address payable[]\",\n    name: \"creatorRecipients\",\n    type: \"address[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"creatorShares\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256\",\n    name: \"sellerRev\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address payable\",\n    name: \"owner\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"getFethAddress\",\n  outputs: [{\n    internalType: \"address\",\n    name: \"fethAddress\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"getFoundationTreasury\",\n  outputs: [{\n    internalType: \"address payable\",\n    name: \"treasuryAddress\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }],\n  name: \"getImmutableRoyalties\",\n  outputs: [{\n    internalType: \"address payable[]\",\n    name: \"recipients\",\n    type: \"address[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"splitPerRecipientInBasisPoints\",\n    type: \"uint256[]\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }],\n  name: \"getMinBidAmount\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"minimum\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }],\n  name: \"getMinOfferAmount\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"minimum\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address payable\",\n    name: \"creator\",\n    type: \"address\"\n  }],\n  name: \"getMutableRoyalties\",\n  outputs: [{\n    internalType: \"address payable[]\",\n    name: \"recipients\",\n    type: \"address[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"splitPerRecipientInBasisPoints\",\n    type: \"uint256[]\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }],\n  name: \"getOffer\",\n  outputs: [{\n    internalType: \"address\",\n    name: \"buyer\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"expiration\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }],\n  name: \"getOfferReferrer\",\n  outputs: [{\n    internalType: \"address payable\",\n    name: \"referrer\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }],\n  name: \"getReserveAuction\",\n  outputs: [{\n    components: [{\n      internalType: \"address\",\n      name: \"nftContract\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"tokenId\",\n      type: \"uint256\"\n    }, {\n      internalType: \"address payable\",\n      name: \"seller\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"duration\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"extensionDuration\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"endTime\",\n      type: \"uint256\"\n    }, {\n      internalType: \"address payable\",\n      name: \"bidder\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"amount\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct NFTMarketReserveAuction.ReserveAuction\",\n    name: \"auction\",\n    type: \"tuple\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }],\n  name: \"getReserveAuctionBidReferrer\",\n  outputs: [{\n    internalType: \"address payable\",\n    name: \"referrer\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }],\n  name: \"getReserveAuctionIdFor\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"getRoyaltyRegistry\",\n  outputs: [{\n    internalType: \"address\",\n    name: \"registry\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }],\n  name: \"getTokenCreator\",\n  outputs: [{\n    internalType: \"address payable\",\n    name: \"creator\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"initialize\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }],\n  name: \"makeOffer\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"expiration\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address payable\",\n    name: \"referrer\",\n    type: \"address\"\n  }],\n  name: \"makeOfferV2\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"expiration\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }],\n  name: \"placeBid\",\n  outputs: [],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address payable\",\n    name: \"referrer\",\n    type: \"address\"\n  }],\n  name: \"placeBidV2\",\n  outputs: [],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"price\",\n    type: \"uint256\"\n  }],\n  name: \"setBuyPrice\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"reservePrice\",\n    type: \"uint256\"\n  }],\n  name: \"updateReserveAuction\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  stateMutability: \"payable\",\n  type: \"receive\"\n}];\nvar FoundationTrade = /*#__PURE__*/function (_NFTTrade) {\n  _inheritsLoose(FoundationTrade, _NFTTrade);\n  function FoundationTrade(orders) {\n    return _NFTTrade.call(this, exports.Market.Foundation, orders) || this;\n  }\n  var _proto = FoundationTrade.prototype;\n  _proto.encode = function encode(planner, config) {\n    for (var _iterator = _createForOfIteratorHelperLoose(this.orders), _step; !(_step = _iterator()).done;) {\n      var item = _step.value;\n      var calldata = FoundationTrade.INTERFACE.encodeFunctionData('buyV2', [item.tokenAddress, item.tokenId, item.price, item.referrer]);\n      planner.addCommand(CommandType.FOUNDATION, [item.price, calldata, item.recipient, item.tokenAddress, item.tokenId], config.allowRevert);\n    }\n  };\n  _proto.getBuyItems = function getBuyItems() {\n    var buyItems = [];\n    for (var _iterator2 = _createForOfIteratorHelperLoose(this.orders), _step2; !(_step2 = _iterator2()).done;) {\n      var item = _step2.value;\n      buyItems.push({\n        tokenAddress: item.tokenAddress,\n        tokenId: item.tokenId,\n        tokenType: exports.TokenType.ERC721\n      });\n    }\n    return buyItems;\n  };\n  _proto.getTotalPrice = function getTotalPrice() {\n    var total = ethers.BigNumber.from(0);\n    for (var _iterator3 = _createForOfIteratorHelperLoose(this.orders), _step3; !(_step3 = _iterator3()).done;) {\n      var item = _step3.value;\n      total = total.add(item.price);\n    }\n    return total;\n  };\n  return FoundationTrade;\n}(NFTTrade);\nFoundationTrade.INTERFACE = /*#__PURE__*/new abi$7.Interface(abi);\nvar abi$1 = [{\n  inputs: [{\n    internalType: \"address\",\n    name: \"_currencyManager\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"_executionManager\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"_royaltyFeeManager\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"_WETH\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"_protocolFeeRecipient\",\n    type: \"address\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"constructor\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"user\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"newMinNonce\",\n    type: \"uint256\"\n  }],\n  name: \"CancelAllOrders\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"user\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256[]\",\n    name: \"orderNonces\",\n    type: \"uint256[]\"\n  }],\n  name: \"CancelMultipleOrders\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"currencyManager\",\n    type: \"address\"\n  }],\n  name: \"NewCurrencyManager\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"executionManager\",\n    type: \"address\"\n  }],\n  name: \"NewExecutionManager\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"protocolFeeRecipient\",\n    type: \"address\"\n  }],\n  name: \"NewProtocolFeeRecipient\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"royaltyFeeManager\",\n    type: \"address\"\n  }],\n  name: \"NewRoyaltyFeeManager\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"transferSelectorNFT\",\n    type: \"address\"\n  }],\n  name: \"NewTransferSelectorNFT\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"previousOwner\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"newOwner\",\n    type: \"address\"\n  }],\n  name: \"OwnershipTransferred\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"collection\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"royaltyRecipient\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"currency\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }],\n  name: \"RoyaltyPayment\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"bytes32\",\n    name: \"orderHash\",\n    type: \"bytes32\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"orderNonce\",\n    type: \"uint256\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"taker\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"maker\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"strategy\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"currency\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"collection\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"price\",\n    type: \"uint256\"\n  }],\n  name: \"TakerAsk\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"bytes32\",\n    name: \"orderHash\",\n    type: \"bytes32\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"orderNonce\",\n    type: \"uint256\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"taker\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"maker\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"strategy\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"currency\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"collection\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"price\",\n    type: \"uint256\"\n  }],\n  name: \"TakerBid\",\n  type: \"event\"\n}, {\n  inputs: [],\n  name: \"DOMAIN_SEPARATOR\",\n  outputs: [{\n    internalType: \"bytes32\",\n    name: \"\",\n    type: \"bytes32\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"WETH\",\n  outputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"minNonce\",\n    type: \"uint256\"\n  }],\n  name: \"cancelAllOrdersForSender\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256[]\",\n    name: \"orderNonces\",\n    type: \"uint256[]\"\n  }],\n  name: \"cancelMultipleMakerOrders\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"currencyManager\",\n  outputs: [{\n    internalType: \"contract ICurrencyManager\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"executionManager\",\n  outputs: [{\n    internalType: \"contract IExecutionManager\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"user\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"orderNonce\",\n    type: \"uint256\"\n  }],\n  name: \"isUserOrderNonceExecutedOrCancelled\",\n  outputs: [{\n    internalType: \"bool\",\n    name: \"\",\n    type: \"bool\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      internalType: \"bool\",\n      name: \"isOrderAsk\",\n      type: \"bool\"\n    }, {\n      internalType: \"address\",\n      name: \"taker\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"price\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"tokenId\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"minPercentageToAsk\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes\",\n      name: \"params\",\n      type: \"bytes\"\n    }],\n    internalType: \"struct OrderTypes.TakerOrder\",\n    name: \"takerBid\",\n    type: \"tuple\"\n  }, {\n    components: [{\n      internalType: \"bool\",\n      name: \"isOrderAsk\",\n      type: \"bool\"\n    }, {\n      internalType: \"address\",\n      name: \"signer\",\n      type: \"address\"\n    }, {\n      internalType: \"address\",\n      name: \"collection\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"price\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"tokenId\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"amount\",\n      type: \"uint256\"\n    }, {\n      internalType: \"address\",\n      name: \"strategy\",\n      type: \"address\"\n    }, {\n      internalType: \"address\",\n      name: \"currency\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"nonce\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"startTime\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"endTime\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"minPercentageToAsk\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes\",\n      name: \"params\",\n      type: \"bytes\"\n    }, {\n      internalType: \"uint8\",\n      name: \"v\",\n      type: \"uint8\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"r\",\n      type: \"bytes32\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"s\",\n      type: \"bytes32\"\n    }],\n    internalType: \"struct OrderTypes.MakerOrder\",\n    name: \"makerAsk\",\n    type: \"tuple\"\n  }],\n  name: \"matchAskWithTakerBid\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      internalType: \"bool\",\n      name: \"isOrderAsk\",\n      type: \"bool\"\n    }, {\n      internalType: \"address\",\n      name: \"taker\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"price\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"tokenId\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"minPercentageToAsk\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes\",\n      name: \"params\",\n      type: \"bytes\"\n    }],\n    internalType: \"struct OrderTypes.TakerOrder\",\n    name: \"takerBid\",\n    type: \"tuple\"\n  }, {\n    components: [{\n      internalType: \"bool\",\n      name: \"isOrderAsk\",\n      type: \"bool\"\n    }, {\n      internalType: \"address\",\n      name: \"signer\",\n      type: \"address\"\n    }, {\n      internalType: \"address\",\n      name: \"collection\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"price\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"tokenId\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"amount\",\n      type: \"uint256\"\n    }, {\n      internalType: \"address\",\n      name: \"strategy\",\n      type: \"address\"\n    }, {\n      internalType: \"address\",\n      name: \"currency\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"nonce\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"startTime\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"endTime\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"minPercentageToAsk\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes\",\n      name: \"params\",\n      type: \"bytes\"\n    }, {\n      internalType: \"uint8\",\n      name: \"v\",\n      type: \"uint8\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"r\",\n      type: \"bytes32\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"s\",\n      type: \"bytes32\"\n    }],\n    internalType: \"struct OrderTypes.MakerOrder\",\n    name: \"makerAsk\",\n    type: \"tuple\"\n  }],\n  name: \"matchAskWithTakerBidUsingETHAndWETH\",\n  outputs: [],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      internalType: \"bool\",\n      name: \"isOrderAsk\",\n      type: \"bool\"\n    }, {\n      internalType: \"address\",\n      name: \"taker\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"price\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"tokenId\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"minPercentageToAsk\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes\",\n      name: \"params\",\n      type: \"bytes\"\n    }],\n    internalType: \"struct OrderTypes.TakerOrder\",\n    name: \"takerAsk\",\n    type: \"tuple\"\n  }, {\n    components: [{\n      internalType: \"bool\",\n      name: \"isOrderAsk\",\n      type: \"bool\"\n    }, {\n      internalType: \"address\",\n      name: \"signer\",\n      type: \"address\"\n    }, {\n      internalType: \"address\",\n      name: \"collection\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"price\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"tokenId\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"amount\",\n      type: \"uint256\"\n    }, {\n      internalType: \"address\",\n      name: \"strategy\",\n      type: \"address\"\n    }, {\n      internalType: \"address\",\n      name: \"currency\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"nonce\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"startTime\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"endTime\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"minPercentageToAsk\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes\",\n      name: \"params\",\n      type: \"bytes\"\n    }, {\n      internalType: \"uint8\",\n      name: \"v\",\n      type: \"uint8\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"r\",\n      type: \"bytes32\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"s\",\n      type: \"bytes32\"\n    }],\n    internalType: \"struct OrderTypes.MakerOrder\",\n    name: \"makerBid\",\n    type: \"tuple\"\n  }],\n  name: \"matchBidWithTakerAsk\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"owner\",\n  outputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"protocolFeeRecipient\",\n  outputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"renounceOwnership\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"royaltyFeeManager\",\n  outputs: [{\n    internalType: \"contract IRoyaltyFeeManager\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"newOwner\",\n    type: \"address\"\n  }],\n  name: \"transferOwnership\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"transferSelectorNFT\",\n  outputs: [{\n    internalType: \"contract ITransferSelectorNFT\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"_currencyManager\",\n    type: \"address\"\n  }],\n  name: \"updateCurrencyManager\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"_executionManager\",\n    type: \"address\"\n  }],\n  name: \"updateExecutionManager\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"_protocolFeeRecipient\",\n    type: \"address\"\n  }],\n  name: \"updateProtocolFeeRecipient\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"_royaltyFeeManager\",\n    type: \"address\"\n  }],\n  name: \"updateRoyaltyFeeManager\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"_transferSelectorNFT\",\n    type: \"address\"\n  }],\n  name: \"updateTransferSelectorNFT\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }],\n  name: \"userMinOrderNonce\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}];\nvar LooksRareTrade = /*#__PURE__*/function (_NFTTrade) {\n  _inheritsLoose(LooksRareTrade, _NFTTrade);\n  function LooksRareTrade(orders) {\n    return _NFTTrade.call(this, exports.Market.LooksRare, orders) || this;\n  }\n  var _proto = LooksRareTrade.prototype;\n  _proto.encode = function encode(planner, config) {\n    for (var _iterator = _createForOfIteratorHelperLoose(this.orders), _step; !(_step = _iterator()).done;) {\n      var item = _step.value;\n      var calldata = LooksRareTrade.INTERFACE.encodeFunctionData('matchAskWithTakerBidUsingETHAndWETH', [item.takerOrder, item.makerOrder]);\n      if (item.tokenType == exports.TokenType.ERC721) {\n        !(item.makerOrder.amount == 1) ? invariant(false, 'ERC721 token amount must be 1') : void 0;\n        planner.addCommand(CommandType.LOOKS_RARE_721, [item.makerOrder.price, calldata, item.recipient, item.makerOrder.collection, item.makerOrder.tokenId], config.allowRevert);\n      } else if (item.tokenType == exports.TokenType.ERC1155) {\n        planner.addCommand(CommandType.LOOKS_RARE_1155, [item.makerOrder.price, calldata, item.recipient, item.makerOrder.collection, item.makerOrder.tokenId, item.makerOrder.amount], config.allowRevert);\n      }\n    }\n  };\n  _proto.getBuyItems = function getBuyItems() {\n    var buyItems = [];\n    for (var _iterator2 = _createForOfIteratorHelperLoose(this.orders), _step2; !(_step2 = _iterator2()).done;) {\n      var item = _step2.value;\n      buyItems.push({\n        tokenAddress: item.makerOrder.collection,\n        tokenId: item.makerOrder.tokenId,\n        tokenType: item.tokenType\n      });\n    }\n    return buyItems;\n  };\n  _proto.getTotalPrice = function getTotalPrice() {\n    var total = ethers.BigNumber.from(0);\n    for (var _iterator3 = _createForOfIteratorHelperLoose(this.orders), _step3; !(_step3 = _iterator3()).done;) {\n      var item = _step3.value;\n      total = total.add(item.makerOrder.price);\n    }\n    return total;\n  };\n  return LooksRareTrade;\n}(NFTTrade);\nLooksRareTrade.INTERFACE = /*#__PURE__*/new abi$7.Interface(abi$1);\nvar abi$2 = [{\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"previousOwner\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"newOwner\",\n    type: \"address\"\n  }],\n  name: \"OwnershipTransferred\",\n  type: \"event\"\n}, {\n  inputs: [],\n  name: \"ETH\",\n  outputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"NFT20\",\n  outputs: [{\n    internalType: \"contract INFT20Factory\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"UNIV2\",\n  outputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"UNIV3\",\n  outputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"WETH\",\n  outputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"_nft\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"_toIds\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"_toAmounts\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"address\",\n    name: \"_receipient\",\n    type: \"address\"\n  }, {\n    internalType: \"uint24\",\n    name: \"_fee\",\n    type: \"uint24\"\n  }, {\n    internalType: \"bool\",\n    name: \"isV3\",\n    type: \"bool\"\n  }],\n  name: \"ethForNft\",\n  outputs: [],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"_nft\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"_ids\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"_amounts\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"bool\",\n    name: \"isErc721\",\n    type: \"bool\"\n  }, {\n    internalType: \"uint24\",\n    name: \"_fee\",\n    type: \"uint24\"\n  }, {\n    internalType: \"bool\",\n    name: \"isV3\",\n    type: \"bool\"\n  }],\n  name: \"nftForEth\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"owner\",\n  outputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"tokenAddress\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenAmount\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address\",\n    name: \"sendTo\",\n    type: \"address\"\n  }],\n  name: \"recoverERC20\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"renounceOwnership\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"_registry\",\n    type: \"address\"\n  }],\n  name: \"setNFT20\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"newOwner\",\n    type: \"address\"\n  }],\n  name: \"transferOwnership\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"withdrawEth\",\n  outputs: [],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  stateMutability: \"payable\",\n  type: \"receive\"\n}];\nvar NFT20Trade = /*#__PURE__*/function (_NFTTrade) {\n  _inheritsLoose(NFT20Trade, _NFTTrade);\n  function NFT20Trade(orders) {\n    return _NFTTrade.call(this, exports.Market.NFT20, orders) || this;\n  }\n  var _proto = NFT20Trade.prototype;\n  _proto.encode = function encode(planner, config) {\n    for (var _iterator = _createForOfIteratorHelperLoose(this.orders), _step; !(_step = _iterator()).done;) {\n      var order = _step.value;\n      var calldata = NFT20Trade.INTERFACE.encodeFunctionData('ethForNft', [order.tokenAddress, order.tokenIds, order.tokenAmounts, order.recipient, order.fee, order.isV3]);\n      planner.addCommand(CommandType.NFT20, [order.value, calldata], config.allowRevert);\n    }\n  };\n  _proto.getBuyItems = function getBuyItems() {\n    var buyItems = [];\n    for (var _iterator2 = _createForOfIteratorHelperLoose(this.orders), _step2; !(_step2 = _iterator2()).done;) {\n      var pool = _step2.value;\n      for (var _iterator3 = _createForOfIteratorHelperLoose(pool.tokenIds), _step3; !(_step3 = _iterator3()).done;) {\n        var tokenId = _step3.value;\n        buyItems.push({\n          tokenAddress: pool.tokenAddress,\n          tokenId: tokenId,\n          tokenType: exports.TokenType.ERC721\n        });\n      }\n    }\n    return buyItems;\n  };\n  _proto.getTotalPrice = function getTotalPrice() {\n    var total = ethers.BigNumber.from(0);\n    for (var _iterator4 = _createForOfIteratorHelperLoose(this.orders), _step4; !(_step4 = _iterator4()).done;) {\n      var item = _step4.value;\n      total = total.add(item.value);\n    }\n    return total;\n  };\n  return NFT20Trade;\n}(NFTTrade);\nNFT20Trade.INTERFACE = /*#__PURE__*/new abi$7.Interface(abi$2);\nvar abi$3 = [{\n  inputs: [{\n    internalType: \"address\",\n    name: \"_nftxFactory\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"_sushiRouter\",\n    type: \"address\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"constructor\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"count\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"ethSpent\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }],\n  name: \"Buy\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"previousOwner\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"newOwner\",\n    type: \"address\"\n  }],\n  name: \"OwnershipTransferred\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"count\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"ethReceived\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }],\n  name: \"Sell\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"count\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"ethSpent\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }],\n  name: \"Swap\",\n  type: \"event\"\n}, {\n  inputs: [],\n  name: \"WETH\",\n  outputs: [{\n    internalType: \"contract IWETH\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"vaultId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"specificIds\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"address[]\",\n    name: \"path\",\n    type: \"address[]\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }],\n  name: \"buyAndRedeem\",\n  outputs: [],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"vaultId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"specificIds\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256\",\n    name: \"maxWethIn\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address[]\",\n    name: \"path\",\n    type: \"address[]\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }],\n  name: \"buyAndRedeemWETH\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"vaultId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"idsIn\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"amounts\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"specificIds\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"address[]\",\n    name: \"path\",\n    type: \"address[]\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }],\n  name: \"buyAndSwap1155\",\n  outputs: [],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"vaultId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"idsIn\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"amounts\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"specificIds\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256\",\n    name: \"maxWethIn\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address[]\",\n    name: \"path\",\n    type: \"address[]\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }],\n  name: \"buyAndSwap1155WETH\",\n  outputs: [],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"vaultId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"idsIn\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"specificIds\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"address[]\",\n    name: \"path\",\n    type: \"address[]\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }],\n  name: \"buyAndSwap721\",\n  outputs: [],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"vaultId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"idsIn\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"specificIds\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256\",\n    name: \"maxWethIn\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address[]\",\n    name: \"path\",\n    type: \"address[]\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }],\n  name: \"buyAndSwap721WETH\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"lpStaking\",\n  outputs: [{\n    internalType: \"contract INFTXLPStaking\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"vaultId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"ids\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"amounts\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256\",\n    name: \"minWethOut\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address[]\",\n    name: \"path\",\n    type: \"address[]\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }],\n  name: \"mintAndSell1155\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"vaultId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"ids\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"amounts\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256\",\n    name: \"minWethOut\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address[]\",\n    name: \"path\",\n    type: \"address[]\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }],\n  name: \"mintAndSell1155WETH\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"vaultId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"ids\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256\",\n    name: \"minEthOut\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address[]\",\n    name: \"path\",\n    type: \"address[]\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }],\n  name: \"mintAndSell721\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"vaultId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"ids\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256\",\n    name: \"minWethOut\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address[]\",\n    name: \"path\",\n    type: \"address[]\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }],\n  name: \"mintAndSell721WETH\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"nftxFactory\",\n  outputs: [{\n    internalType: \"contract INFTXVaultFactory\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"bytes\",\n    name: \"\",\n    type: \"bytes\"\n  }],\n  name: \"onERC1155BatchReceived\",\n  outputs: [{\n    internalType: \"bytes4\",\n    name: \"\",\n    type: \"bytes4\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"\",\n    type: \"uint256\"\n  }, {\n    internalType: \"bytes\",\n    name: \"\",\n    type: \"bytes\"\n  }],\n  name: \"onERC1155Received\",\n  outputs: [{\n    internalType: \"bytes4\",\n    name: \"\",\n    type: \"bytes4\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"\",\n    type: \"uint256\"\n  }, {\n    internalType: \"bytes\",\n    name: \"\",\n    type: \"bytes\"\n  }],\n  name: \"onERC721Received\",\n  outputs: [{\n    internalType: \"bytes4\",\n    name: \"\",\n    type: \"bytes4\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"owner\",\n  outputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"renounceOwnership\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"token\",\n    type: \"address\"\n  }],\n  name: \"rescue\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"bytes4\",\n    name: \"interfaceId\",\n    type: \"bytes4\"\n  }],\n  name: \"supportsInterface\",\n  outputs: [{\n    internalType: \"bool\",\n    name: \"\",\n    type: \"bool\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"sushiRouter\",\n  outputs: [{\n    internalType: \"contract IUniswapV2Router01\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"newOwner\",\n    type: \"address\"\n  }],\n  name: \"transferOwnership\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  stateMutability: \"payable\",\n  type: \"receive\"\n}];\nvar NFTXTrade = /*#__PURE__*/function (_NFTTrade) {\n  _inheritsLoose(NFTXTrade, _NFTTrade);\n  function NFTXTrade(orders) {\n    return _NFTTrade.call(this, exports.Market.NFTX, orders) || this;\n  }\n  var _proto = NFTXTrade.prototype;\n  _proto.encode = function encode(planner, config) {\n    for (var _iterator = _createForOfIteratorHelperLoose(this.orders), _step; !(_step = _iterator()).done;) {\n      var order = _step.value;\n      var calldata = NFTXTrade.INTERFACE.encodeFunctionData('buyAndRedeem', [order.vaultId, order.tokenIds.length, order.tokenIds, [sdkCore.Ether.onChain(1).wrapped.address, order.vaultAddress], order.recipient]);\n      planner.addCommand(CommandType.NFTX, [order.value, calldata], config.allowRevert);\n    }\n  };\n  _proto.getBuyItems = function getBuyItems() {\n    var buyItems = [];\n    for (var _iterator2 = _createForOfIteratorHelperLoose(this.orders), _step2; !(_step2 = _iterator2()).done;) {\n      var order = _step2.value;\n      for (var _iterator3 = _createForOfIteratorHelperLoose(order.tokenIds), _step3; !(_step3 = _iterator3()).done;) {\n        var tokenId = _step3.value;\n        buyItems.push({\n          tokenAddress: order.tokenAddress,\n          tokenId: tokenId,\n          tokenType: exports.TokenType.ERC721\n        });\n      }\n    }\n    return buyItems;\n  };\n  _proto.getTotalPrice = function getTotalPrice() {\n    var total = ethers.BigNumber.from(0);\n    for (var _iterator4 = _createForOfIteratorHelperLoose(this.orders), _step4; !(_step4 = _iterator4()).done;) {\n      var item = _step4.value;\n      total = total.add(item.value);\n    }\n    return total;\n  };\n  return NFTXTrade;\n}(NFTTrade);\nNFTXTrade.INTERFACE = /*#__PURE__*/new abi$7.Interface(abi$3);\nvar abi$4 = [{\n  inputs: [{\n    internalType: \"address\",\n    name: \"conduitController\",\n    type: \"address\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"constructor\"\n}, {\n  inputs: [],\n  name: \"BadContractSignature\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"BadFraction\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"token\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"from\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }],\n  name: \"BadReturnValueFromERC20OnTransfer\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"uint8\",\n    name: \"v\",\n    type: \"uint8\"\n  }],\n  name: \"BadSignatureV\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"ConsiderationCriteriaResolverOutOfRange\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"orderIndex\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"considerationIndex\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"shortfallAmount\",\n    type: \"uint256\"\n  }],\n  name: \"ConsiderationNotMet\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"CriteriaNotEnabledForItem\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"token\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"from\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"identifiers\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"amounts\",\n    type: \"uint256[]\"\n  }],\n  name: \"ERC1155BatchTransferGenericFailure\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"account\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }],\n  name: \"EtherTransferGenericFailure\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"InexactFraction\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"InsufficientEtherSupplied\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"Invalid1155BatchTransferEncoding\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"InvalidBasicOrderParameterEncoding\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"conduit\",\n    type: \"address\"\n  }],\n  name: \"InvalidCallToConduit\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"InvalidCanceller\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"bytes32\",\n    name: \"conduitKey\",\n    type: \"bytes32\"\n  }, {\n    internalType: \"address\",\n    name: \"conduit\",\n    type: \"address\"\n  }],\n  name: \"InvalidConduit\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"InvalidERC721TransferAmount\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"InvalidFulfillmentComponentData\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"value\",\n    type: \"uint256\"\n  }],\n  name: \"InvalidMsgValue\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"InvalidNativeOfferItem\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"InvalidProof\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"bytes32\",\n    name: \"orderHash\",\n    type: \"bytes32\"\n  }],\n  name: \"InvalidRestrictedOrder\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"InvalidSignature\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"InvalidSigner\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"InvalidTime\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"MismatchedFulfillmentOfferAndConsiderationComponents\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"enum Side\",\n    name: \"side\",\n    type: \"uint8\"\n  }],\n  name: \"MissingFulfillmentComponentOnAggregation\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"MissingItemAmount\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"MissingOriginalConsiderationItems\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"account\",\n    type: \"address\"\n  }],\n  name: \"NoContract\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NoReentrantCalls\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NoSpecifiedOrdersAvailable\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"OfferAndConsiderationRequiredOnFulfillment\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"OfferCriteriaResolverOutOfRange\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"bytes32\",\n    name: \"orderHash\",\n    type: \"bytes32\"\n  }],\n  name: \"OrderAlreadyFilled\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"OrderCriteriaResolverOutOfRange\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"bytes32\",\n    name: \"orderHash\",\n    type: \"bytes32\"\n  }],\n  name: \"OrderIsCancelled\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"bytes32\",\n    name: \"orderHash\",\n    type: \"bytes32\"\n  }],\n  name: \"OrderPartiallyFilled\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"PartialFillsNotEnabledForOrder\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"token\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"from\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"identifier\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }],\n  name: \"TokenTransferGenericFailure\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"UnresolvedConsiderationCriteria\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"UnresolvedOfferCriteria\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"UnusedItemParameters\",\n  type: \"error\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"newCounter\",\n    type: \"uint256\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"offerer\",\n    type: \"address\"\n  }],\n  name: \"CounterIncremented\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"bytes32\",\n    name: \"orderHash\",\n    type: \"bytes32\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"offerer\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"zone\",\n    type: \"address\"\n  }],\n  name: \"OrderCancelled\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"bytes32\",\n    name: \"orderHash\",\n    type: \"bytes32\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"offerer\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"zone\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"recipient\",\n    type: \"address\"\n  }, {\n    components: [{\n      internalType: \"enum ItemType\",\n      name: \"itemType\",\n      type: \"uint8\"\n    }, {\n      internalType: \"address\",\n      name: \"token\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"identifier\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"amount\",\n      type: \"uint256\"\n    }],\n    indexed: false,\n    internalType: \"struct SpentItem[]\",\n    name: \"offer\",\n    type: \"tuple[]\"\n  }, {\n    components: [{\n      internalType: \"enum ItemType\",\n      name: \"itemType\",\n      type: \"uint8\"\n    }, {\n      internalType: \"address\",\n      name: \"token\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"identifier\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"amount\",\n      type: \"uint256\"\n    }, {\n      internalType: \"address payable\",\n      name: \"recipient\",\n      type: \"address\"\n    }],\n    indexed: false,\n    internalType: \"struct ReceivedItem[]\",\n    name: \"consideration\",\n    type: \"tuple[]\"\n  }],\n  name: \"OrderFulfilled\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"bytes32\",\n    name: \"orderHash\",\n    type: \"bytes32\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"offerer\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"zone\",\n    type: \"address\"\n  }],\n  name: \"OrderValidated\",\n  type: \"event\"\n}, {\n  inputs: [{\n    components: [{\n      internalType: \"address\",\n      name: \"offerer\",\n      type: \"address\"\n    }, {\n      internalType: \"address\",\n      name: \"zone\",\n      type: \"address\"\n    }, {\n      components: [{\n        internalType: \"enum ItemType\",\n        name: \"itemType\",\n        type: \"uint8\"\n      }, {\n        internalType: \"address\",\n        name: \"token\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256\",\n        name: \"identifierOrCriteria\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"startAmount\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"endAmount\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct OfferItem[]\",\n      name: \"offer\",\n      type: \"tuple[]\"\n    }, {\n      components: [{\n        internalType: \"enum ItemType\",\n        name: \"itemType\",\n        type: \"uint8\"\n      }, {\n        internalType: \"address\",\n        name: \"token\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256\",\n        name: \"identifierOrCriteria\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"startAmount\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"endAmount\",\n        type: \"uint256\"\n      }, {\n        internalType: \"address payable\",\n        name: \"recipient\",\n        type: \"address\"\n      }],\n      internalType: \"struct ConsiderationItem[]\",\n      name: \"consideration\",\n      type: \"tuple[]\"\n    }, {\n      internalType: \"enum OrderType\",\n      name: \"orderType\",\n      type: \"uint8\"\n    }, {\n      internalType: \"uint256\",\n      name: \"startTime\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"endTime\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"zoneHash\",\n      type: \"bytes32\"\n    }, {\n      internalType: \"uint256\",\n      name: \"salt\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"conduitKey\",\n      type: \"bytes32\"\n    }, {\n      internalType: \"uint256\",\n      name: \"counter\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct OrderComponents[]\",\n    name: \"orders\",\n    type: \"tuple[]\"\n  }],\n  name: \"cancel\",\n  outputs: [{\n    internalType: \"bool\",\n    name: \"cancelled\",\n    type: \"bool\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"address\",\n        name: \"offerer\",\n        type: \"address\"\n      }, {\n        internalType: \"address\",\n        name: \"zone\",\n        type: \"address\"\n      }, {\n        components: [{\n          internalType: \"enum ItemType\",\n          name: \"itemType\",\n          type: \"uint8\"\n        }, {\n          internalType: \"address\",\n          name: \"token\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256\",\n          name: \"identifierOrCriteria\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"startAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"endAmount\",\n          type: \"uint256\"\n        }],\n        internalType: \"struct OfferItem[]\",\n        name: \"offer\",\n        type: \"tuple[]\"\n      }, {\n        components: [{\n          internalType: \"enum ItemType\",\n          name: \"itemType\",\n          type: \"uint8\"\n        }, {\n          internalType: \"address\",\n          name: \"token\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256\",\n          name: \"identifierOrCriteria\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"startAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"endAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"address payable\",\n          name: \"recipient\",\n          type: \"address\"\n        }],\n        internalType: \"struct ConsiderationItem[]\",\n        name: \"consideration\",\n        type: \"tuple[]\"\n      }, {\n        internalType: \"enum OrderType\",\n        name: \"orderType\",\n        type: \"uint8\"\n      }, {\n        internalType: \"uint256\",\n        name: \"startTime\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"endTime\",\n        type: \"uint256\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"zoneHash\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"uint256\",\n        name: \"salt\",\n        type: \"uint256\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"conduitKey\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"uint256\",\n        name: \"totalOriginalConsiderationItems\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct OrderParameters\",\n      name: \"parameters\",\n      type: \"tuple\"\n    }, {\n      internalType: \"uint120\",\n      name: \"numerator\",\n      type: \"uint120\"\n    }, {\n      internalType: \"uint120\",\n      name: \"denominator\",\n      type: \"uint120\"\n    }, {\n      internalType: \"bytes\",\n      name: \"signature\",\n      type: \"bytes\"\n    }, {\n      internalType: \"bytes\",\n      name: \"extraData\",\n      type: \"bytes\"\n    }],\n    internalType: \"struct AdvancedOrder\",\n    name: \"advancedOrder\",\n    type: \"tuple\"\n  }, {\n    components: [{\n      internalType: \"uint256\",\n      name: \"orderIndex\",\n      type: \"uint256\"\n    }, {\n      internalType: \"enum Side\",\n      name: \"side\",\n      type: \"uint8\"\n    }, {\n      internalType: \"uint256\",\n      name: \"index\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"identifier\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes32[]\",\n      name: \"criteriaProof\",\n      type: \"bytes32[]\"\n    }],\n    internalType: \"struct CriteriaResolver[]\",\n    name: \"criteriaResolvers\",\n    type: \"tuple[]\"\n  }, {\n    internalType: \"bytes32\",\n    name: \"fulfillerConduitKey\",\n    type: \"bytes32\"\n  }, {\n    internalType: \"address\",\n    name: \"recipient\",\n    type: \"address\"\n  }],\n  name: \"fulfillAdvancedOrder\",\n  outputs: [{\n    internalType: \"bool\",\n    name: \"fulfilled\",\n    type: \"bool\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"address\",\n        name: \"offerer\",\n        type: \"address\"\n      }, {\n        internalType: \"address\",\n        name: \"zone\",\n        type: \"address\"\n      }, {\n        components: [{\n          internalType: \"enum ItemType\",\n          name: \"itemType\",\n          type: \"uint8\"\n        }, {\n          internalType: \"address\",\n          name: \"token\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256\",\n          name: \"identifierOrCriteria\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"startAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"endAmount\",\n          type: \"uint256\"\n        }],\n        internalType: \"struct OfferItem[]\",\n        name: \"offer\",\n        type: \"tuple[]\"\n      }, {\n        components: [{\n          internalType: \"enum ItemType\",\n          name: \"itemType\",\n          type: \"uint8\"\n        }, {\n          internalType: \"address\",\n          name: \"token\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256\",\n          name: \"identifierOrCriteria\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"startAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"endAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"address payable\",\n          name: \"recipient\",\n          type: \"address\"\n        }],\n        internalType: \"struct ConsiderationItem[]\",\n        name: \"consideration\",\n        type: \"tuple[]\"\n      }, {\n        internalType: \"enum OrderType\",\n        name: \"orderType\",\n        type: \"uint8\"\n      }, {\n        internalType: \"uint256\",\n        name: \"startTime\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"endTime\",\n        type: \"uint256\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"zoneHash\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"uint256\",\n        name: \"salt\",\n        type: \"uint256\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"conduitKey\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"uint256\",\n        name: \"totalOriginalConsiderationItems\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct OrderParameters\",\n      name: \"parameters\",\n      type: \"tuple\"\n    }, {\n      internalType: \"uint120\",\n      name: \"numerator\",\n      type: \"uint120\"\n    }, {\n      internalType: \"uint120\",\n      name: \"denominator\",\n      type: \"uint120\"\n    }, {\n      internalType: \"bytes\",\n      name: \"signature\",\n      type: \"bytes\"\n    }, {\n      internalType: \"bytes\",\n      name: \"extraData\",\n      type: \"bytes\"\n    }],\n    internalType: \"struct AdvancedOrder[]\",\n    name: \"advancedOrders\",\n    type: \"tuple[]\"\n  }, {\n    components: [{\n      internalType: \"uint256\",\n      name: \"orderIndex\",\n      type: \"uint256\"\n    }, {\n      internalType: \"enum Side\",\n      name: \"side\",\n      type: \"uint8\"\n    }, {\n      internalType: \"uint256\",\n      name: \"index\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"identifier\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes32[]\",\n      name: \"criteriaProof\",\n      type: \"bytes32[]\"\n    }],\n    internalType: \"struct CriteriaResolver[]\",\n    name: \"criteriaResolvers\",\n    type: \"tuple[]\"\n  }, {\n    components: [{\n      internalType: \"uint256\",\n      name: \"orderIndex\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"itemIndex\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct FulfillmentComponent[][]\",\n    name: \"offerFulfillments\",\n    type: \"tuple[][]\"\n  }, {\n    components: [{\n      internalType: \"uint256\",\n      name: \"orderIndex\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"itemIndex\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct FulfillmentComponent[][]\",\n    name: \"considerationFulfillments\",\n    type: \"tuple[][]\"\n  }, {\n    internalType: \"bytes32\",\n    name: \"fulfillerConduitKey\",\n    type: \"bytes32\"\n  }, {\n    internalType: \"address\",\n    name: \"recipient\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"maximumFulfilled\",\n    type: \"uint256\"\n  }],\n  name: \"fulfillAvailableAdvancedOrders\",\n  outputs: [{\n    internalType: \"bool[]\",\n    name: \"availableOrders\",\n    type: \"bool[]\"\n  }, {\n    components: [{\n      components: [{\n        internalType: \"enum ItemType\",\n        name: \"itemType\",\n        type: \"uint8\"\n      }, {\n        internalType: \"address\",\n        name: \"token\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256\",\n        name: \"identifier\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\"\n      }, {\n        internalType: \"address payable\",\n        name: \"recipient\",\n        type: \"address\"\n      }],\n      internalType: \"struct ReceivedItem\",\n      name: \"item\",\n      type: \"tuple\"\n    }, {\n      internalType: \"address\",\n      name: \"offerer\",\n      type: \"address\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"conduitKey\",\n      type: \"bytes32\"\n    }],\n    internalType: \"struct Execution[]\",\n    name: \"executions\",\n    type: \"tuple[]\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"address\",\n        name: \"offerer\",\n        type: \"address\"\n      }, {\n        internalType: \"address\",\n        name: \"zone\",\n        type: \"address\"\n      }, {\n        components: [{\n          internalType: \"enum ItemType\",\n          name: \"itemType\",\n          type: \"uint8\"\n        }, {\n          internalType: \"address\",\n          name: \"token\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256\",\n          name: \"identifierOrCriteria\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"startAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"endAmount\",\n          type: \"uint256\"\n        }],\n        internalType: \"struct OfferItem[]\",\n        name: \"offer\",\n        type: \"tuple[]\"\n      }, {\n        components: [{\n          internalType: \"enum ItemType\",\n          name: \"itemType\",\n          type: \"uint8\"\n        }, {\n          internalType: \"address\",\n          name: \"token\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256\",\n          name: \"identifierOrCriteria\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"startAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"endAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"address payable\",\n          name: \"recipient\",\n          type: \"address\"\n        }],\n        internalType: \"struct ConsiderationItem[]\",\n        name: \"consideration\",\n        type: \"tuple[]\"\n      }, {\n        internalType: \"enum OrderType\",\n        name: \"orderType\",\n        type: \"uint8\"\n      }, {\n        internalType: \"uint256\",\n        name: \"startTime\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"endTime\",\n        type: \"uint256\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"zoneHash\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"uint256\",\n        name: \"salt\",\n        type: \"uint256\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"conduitKey\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"uint256\",\n        name: \"totalOriginalConsiderationItems\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct OrderParameters\",\n      name: \"parameters\",\n      type: \"tuple\"\n    }, {\n      internalType: \"bytes\",\n      name: \"signature\",\n      type: \"bytes\"\n    }],\n    internalType: \"struct Order[]\",\n    name: \"orders\",\n    type: \"tuple[]\"\n  }, {\n    components: [{\n      internalType: \"uint256\",\n      name: \"orderIndex\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"itemIndex\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct FulfillmentComponent[][]\",\n    name: \"offerFulfillments\",\n    type: \"tuple[][]\"\n  }, {\n    components: [{\n      internalType: \"uint256\",\n      name: \"orderIndex\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"itemIndex\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct FulfillmentComponent[][]\",\n    name: \"considerationFulfillments\",\n    type: \"tuple[][]\"\n  }, {\n    internalType: \"bytes32\",\n    name: \"fulfillerConduitKey\",\n    type: \"bytes32\"\n  }, {\n    internalType: \"uint256\",\n    name: \"maximumFulfilled\",\n    type: \"uint256\"\n  }],\n  name: \"fulfillAvailableOrders\",\n  outputs: [{\n    internalType: \"bool[]\",\n    name: \"availableOrders\",\n    type: \"bool[]\"\n  }, {\n    components: [{\n      components: [{\n        internalType: \"enum ItemType\",\n        name: \"itemType\",\n        type: \"uint8\"\n      }, {\n        internalType: \"address\",\n        name: \"token\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256\",\n        name: \"identifier\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\"\n      }, {\n        internalType: \"address payable\",\n        name: \"recipient\",\n        type: \"address\"\n      }],\n      internalType: \"struct ReceivedItem\",\n      name: \"item\",\n      type: \"tuple\"\n    }, {\n      internalType: \"address\",\n      name: \"offerer\",\n      type: \"address\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"conduitKey\",\n      type: \"bytes32\"\n    }],\n    internalType: \"struct Execution[]\",\n    name: \"executions\",\n    type: \"tuple[]\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      internalType: \"address\",\n      name: \"considerationToken\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"considerationIdentifier\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"considerationAmount\",\n      type: \"uint256\"\n    }, {\n      internalType: \"address payable\",\n      name: \"offerer\",\n      type: \"address\"\n    }, {\n      internalType: \"address\",\n      name: \"zone\",\n      type: \"address\"\n    }, {\n      internalType: \"address\",\n      name: \"offerToken\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"offerIdentifier\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"offerAmount\",\n      type: \"uint256\"\n    }, {\n      internalType: \"enum BasicOrderType\",\n      name: \"basicOrderType\",\n      type: \"uint8\"\n    }, {\n      internalType: \"uint256\",\n      name: \"startTime\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"endTime\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"zoneHash\",\n      type: \"bytes32\"\n    }, {\n      internalType: \"uint256\",\n      name: \"salt\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"offererConduitKey\",\n      type: \"bytes32\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"fulfillerConduitKey\",\n      type: \"bytes32\"\n    }, {\n      internalType: \"uint256\",\n      name: \"totalOriginalAdditionalRecipients\",\n      type: \"uint256\"\n    }, {\n      components: [{\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\"\n      }, {\n        internalType: \"address payable\",\n        name: \"recipient\",\n        type: \"address\"\n      }],\n      internalType: \"struct AdditionalRecipient[]\",\n      name: \"additionalRecipients\",\n      type: \"tuple[]\"\n    }, {\n      internalType: \"bytes\",\n      name: \"signature\",\n      type: \"bytes\"\n    }],\n    internalType: \"struct BasicOrderParameters\",\n    name: \"parameters\",\n    type: \"tuple\"\n  }],\n  name: \"fulfillBasicOrder\",\n  outputs: [{\n    internalType: \"bool\",\n    name: \"fulfilled\",\n    type: \"bool\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"address\",\n        name: \"offerer\",\n        type: \"address\"\n      }, {\n        internalType: \"address\",\n        name: \"zone\",\n        type: \"address\"\n      }, {\n        components: [{\n          internalType: \"enum ItemType\",\n          name: \"itemType\",\n          type: \"uint8\"\n        }, {\n          internalType: \"address\",\n          name: \"token\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256\",\n          name: \"identifierOrCriteria\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"startAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"endAmount\",\n          type: \"uint256\"\n        }],\n        internalType: \"struct OfferItem[]\",\n        name: \"offer\",\n        type: \"tuple[]\"\n      }, {\n        components: [{\n          internalType: \"enum ItemType\",\n          name: \"itemType\",\n          type: \"uint8\"\n        }, {\n          internalType: \"address\",\n          name: \"token\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256\",\n          name: \"identifierOrCriteria\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"startAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"endAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"address payable\",\n          name: \"recipient\",\n          type: \"address\"\n        }],\n        internalType: \"struct ConsiderationItem[]\",\n        name: \"consideration\",\n        type: \"tuple[]\"\n      }, {\n        internalType: \"enum OrderType\",\n        name: \"orderType\",\n        type: \"uint8\"\n      }, {\n        internalType: \"uint256\",\n        name: \"startTime\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"endTime\",\n        type: \"uint256\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"zoneHash\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"uint256\",\n        name: \"salt\",\n        type: \"uint256\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"conduitKey\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"uint256\",\n        name: \"totalOriginalConsiderationItems\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct OrderParameters\",\n      name: \"parameters\",\n      type: \"tuple\"\n    }, {\n      internalType: \"bytes\",\n      name: \"signature\",\n      type: \"bytes\"\n    }],\n    internalType: \"struct Order\",\n    name: \"order\",\n    type: \"tuple\"\n  }, {\n    internalType: \"bytes32\",\n    name: \"fulfillerConduitKey\",\n    type: \"bytes32\"\n  }],\n  name: \"fulfillOrder\",\n  outputs: [{\n    internalType: \"bool\",\n    name: \"fulfilled\",\n    type: \"bool\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"offerer\",\n    type: \"address\"\n  }],\n  name: \"getCounter\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"counter\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      internalType: \"address\",\n      name: \"offerer\",\n      type: \"address\"\n    }, {\n      internalType: \"address\",\n      name: \"zone\",\n      type: \"address\"\n    }, {\n      components: [{\n        internalType: \"enum ItemType\",\n        name: \"itemType\",\n        type: \"uint8\"\n      }, {\n        internalType: \"address\",\n        name: \"token\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256\",\n        name: \"identifierOrCriteria\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"startAmount\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"endAmount\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct OfferItem[]\",\n      name: \"offer\",\n      type: \"tuple[]\"\n    }, {\n      components: [{\n        internalType: \"enum ItemType\",\n        name: \"itemType\",\n        type: \"uint8\"\n      }, {\n        internalType: \"address\",\n        name: \"token\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256\",\n        name: \"identifierOrCriteria\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"startAmount\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"endAmount\",\n        type: \"uint256\"\n      }, {\n        internalType: \"address payable\",\n        name: \"recipient\",\n        type: \"address\"\n      }],\n      internalType: \"struct ConsiderationItem[]\",\n      name: \"consideration\",\n      type: \"tuple[]\"\n    }, {\n      internalType: \"enum OrderType\",\n      name: \"orderType\",\n      type: \"uint8\"\n    }, {\n      internalType: \"uint256\",\n      name: \"startTime\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"endTime\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"zoneHash\",\n      type: \"bytes32\"\n    }, {\n      internalType: \"uint256\",\n      name: \"salt\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"conduitKey\",\n      type: \"bytes32\"\n    }, {\n      internalType: \"uint256\",\n      name: \"counter\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct OrderComponents\",\n    name: \"order\",\n    type: \"tuple\"\n  }],\n  name: \"getOrderHash\",\n  outputs: [{\n    internalType: \"bytes32\",\n    name: \"orderHash\",\n    type: \"bytes32\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"bytes32\",\n    name: \"orderHash\",\n    type: \"bytes32\"\n  }],\n  name: \"getOrderStatus\",\n  outputs: [{\n    internalType: \"bool\",\n    name: \"isValidated\",\n    type: \"bool\"\n  }, {\n    internalType: \"bool\",\n    name: \"isCancelled\",\n    type: \"bool\"\n  }, {\n    internalType: \"uint256\",\n    name: \"totalFilled\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"totalSize\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"incrementCounter\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"newCounter\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"information\",\n  outputs: [{\n    internalType: \"string\",\n    name: \"version\",\n    type: \"string\"\n  }, {\n    internalType: \"bytes32\",\n    name: \"domainSeparator\",\n    type: \"bytes32\"\n  }, {\n    internalType: \"address\",\n    name: \"conduitController\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"address\",\n        name: \"offerer\",\n        type: \"address\"\n      }, {\n        internalType: \"address\",\n        name: \"zone\",\n        type: \"address\"\n      }, {\n        components: [{\n          internalType: \"enum ItemType\",\n          name: \"itemType\",\n          type: \"uint8\"\n        }, {\n          internalType: \"address\",\n          name: \"token\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256\",\n          name: \"identifierOrCriteria\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"startAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"endAmount\",\n          type: \"uint256\"\n        }],\n        internalType: \"struct OfferItem[]\",\n        name: \"offer\",\n        type: \"tuple[]\"\n      }, {\n        components: [{\n          internalType: \"enum ItemType\",\n          name: \"itemType\",\n          type: \"uint8\"\n        }, {\n          internalType: \"address\",\n          name: \"token\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256\",\n          name: \"identifierOrCriteria\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"startAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"endAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"address payable\",\n          name: \"recipient\",\n          type: \"address\"\n        }],\n        internalType: \"struct ConsiderationItem[]\",\n        name: \"consideration\",\n        type: \"tuple[]\"\n      }, {\n        internalType: \"enum OrderType\",\n        name: \"orderType\",\n        type: \"uint8\"\n      }, {\n        internalType: \"uint256\",\n        name: \"startTime\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"endTime\",\n        type: \"uint256\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"zoneHash\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"uint256\",\n        name: \"salt\",\n        type: \"uint256\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"conduitKey\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"uint256\",\n        name: \"totalOriginalConsiderationItems\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct OrderParameters\",\n      name: \"parameters\",\n      type: \"tuple\"\n    }, {\n      internalType: \"uint120\",\n      name: \"numerator\",\n      type: \"uint120\"\n    }, {\n      internalType: \"uint120\",\n      name: \"denominator\",\n      type: \"uint120\"\n    }, {\n      internalType: \"bytes\",\n      name: \"signature\",\n      type: \"bytes\"\n    }, {\n      internalType: \"bytes\",\n      name: \"extraData\",\n      type: \"bytes\"\n    }],\n    internalType: \"struct AdvancedOrder[]\",\n    name: \"advancedOrders\",\n    type: \"tuple[]\"\n  }, {\n    components: [{\n      internalType: \"uint256\",\n      name: \"orderIndex\",\n      type: \"uint256\"\n    }, {\n      internalType: \"enum Side\",\n      name: \"side\",\n      type: \"uint8\"\n    }, {\n      internalType: \"uint256\",\n      name: \"index\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"identifier\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes32[]\",\n      name: \"criteriaProof\",\n      type: \"bytes32[]\"\n    }],\n    internalType: \"struct CriteriaResolver[]\",\n    name: \"criteriaResolvers\",\n    type: \"tuple[]\"\n  }, {\n    components: [{\n      components: [{\n        internalType: \"uint256\",\n        name: \"orderIndex\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"itemIndex\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct FulfillmentComponent[]\",\n      name: \"offerComponents\",\n      type: \"tuple[]\"\n    }, {\n      components: [{\n        internalType: \"uint256\",\n        name: \"orderIndex\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"itemIndex\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct FulfillmentComponent[]\",\n      name: \"considerationComponents\",\n      type: \"tuple[]\"\n    }],\n    internalType: \"struct Fulfillment[]\",\n    name: \"fulfillments\",\n    type: \"tuple[]\"\n  }],\n  name: \"matchAdvancedOrders\",\n  outputs: [{\n    components: [{\n      components: [{\n        internalType: \"enum ItemType\",\n        name: \"itemType\",\n        type: \"uint8\"\n      }, {\n        internalType: \"address\",\n        name: \"token\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256\",\n        name: \"identifier\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\"\n      }, {\n        internalType: \"address payable\",\n        name: \"recipient\",\n        type: \"address\"\n      }],\n      internalType: \"struct ReceivedItem\",\n      name: \"item\",\n      type: \"tuple\"\n    }, {\n      internalType: \"address\",\n      name: \"offerer\",\n      type: \"address\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"conduitKey\",\n      type: \"bytes32\"\n    }],\n    internalType: \"struct Execution[]\",\n    name: \"executions\",\n    type: \"tuple[]\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"address\",\n        name: \"offerer\",\n        type: \"address\"\n      }, {\n        internalType: \"address\",\n        name: \"zone\",\n        type: \"address\"\n      }, {\n        components: [{\n          internalType: \"enum ItemType\",\n          name: \"itemType\",\n          type: \"uint8\"\n        }, {\n          internalType: \"address\",\n          name: \"token\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256\",\n          name: \"identifierOrCriteria\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"startAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"endAmount\",\n          type: \"uint256\"\n        }],\n        internalType: \"struct OfferItem[]\",\n        name: \"offer\",\n        type: \"tuple[]\"\n      }, {\n        components: [{\n          internalType: \"enum ItemType\",\n          name: \"itemType\",\n          type: \"uint8\"\n        }, {\n          internalType: \"address\",\n          name: \"token\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256\",\n          name: \"identifierOrCriteria\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"startAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"endAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"address payable\",\n          name: \"recipient\",\n          type: \"address\"\n        }],\n        internalType: \"struct ConsiderationItem[]\",\n        name: \"consideration\",\n        type: \"tuple[]\"\n      }, {\n        internalType: \"enum OrderType\",\n        name: \"orderType\",\n        type: \"uint8\"\n      }, {\n        internalType: \"uint256\",\n        name: \"startTime\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"endTime\",\n        type: \"uint256\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"zoneHash\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"uint256\",\n        name: \"salt\",\n        type: \"uint256\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"conduitKey\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"uint256\",\n        name: \"totalOriginalConsiderationItems\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct OrderParameters\",\n      name: \"parameters\",\n      type: \"tuple\"\n    }, {\n      internalType: \"bytes\",\n      name: \"signature\",\n      type: \"bytes\"\n    }],\n    internalType: \"struct Order[]\",\n    name: \"orders\",\n    type: \"tuple[]\"\n  }, {\n    components: [{\n      components: [{\n        internalType: \"uint256\",\n        name: \"orderIndex\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"itemIndex\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct FulfillmentComponent[]\",\n      name: \"offerComponents\",\n      type: \"tuple[]\"\n    }, {\n      components: [{\n        internalType: \"uint256\",\n        name: \"orderIndex\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"itemIndex\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct FulfillmentComponent[]\",\n      name: \"considerationComponents\",\n      type: \"tuple[]\"\n    }],\n    internalType: \"struct Fulfillment[]\",\n    name: \"fulfillments\",\n    type: \"tuple[]\"\n  }],\n  name: \"matchOrders\",\n  outputs: [{\n    components: [{\n      components: [{\n        internalType: \"enum ItemType\",\n        name: \"itemType\",\n        type: \"uint8\"\n      }, {\n        internalType: \"address\",\n        name: \"token\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256\",\n        name: \"identifier\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\"\n      }, {\n        internalType: \"address payable\",\n        name: \"recipient\",\n        type: \"address\"\n      }],\n      internalType: \"struct ReceivedItem\",\n      name: \"item\",\n      type: \"tuple\"\n    }, {\n      internalType: \"address\",\n      name: \"offerer\",\n      type: \"address\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"conduitKey\",\n      type: \"bytes32\"\n    }],\n    internalType: \"struct Execution[]\",\n    name: \"executions\",\n    type: \"tuple[]\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"name\",\n  outputs: [{\n    internalType: \"string\",\n    name: \"contractName\",\n    type: \"string\"\n  }],\n  stateMutability: \"pure\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"address\",\n        name: \"offerer\",\n        type: \"address\"\n      }, {\n        internalType: \"address\",\n        name: \"zone\",\n        type: \"address\"\n      }, {\n        components: [{\n          internalType: \"enum ItemType\",\n          name: \"itemType\",\n          type: \"uint8\"\n        }, {\n          internalType: \"address\",\n          name: \"token\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256\",\n          name: \"identifierOrCriteria\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"startAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"endAmount\",\n          type: \"uint256\"\n        }],\n        internalType: \"struct OfferItem[]\",\n        name: \"offer\",\n        type: \"tuple[]\"\n      }, {\n        components: [{\n          internalType: \"enum ItemType\",\n          name: \"itemType\",\n          type: \"uint8\"\n        }, {\n          internalType: \"address\",\n          name: \"token\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256\",\n          name: \"identifierOrCriteria\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"startAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"endAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"address payable\",\n          name: \"recipient\",\n          type: \"address\"\n        }],\n        internalType: \"struct ConsiderationItem[]\",\n        name: \"consideration\",\n        type: \"tuple[]\"\n      }, {\n        internalType: \"enum OrderType\",\n        name: \"orderType\",\n        type: \"uint8\"\n      }, {\n        internalType: \"uint256\",\n        name: \"startTime\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"endTime\",\n        type: \"uint256\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"zoneHash\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"uint256\",\n        name: \"salt\",\n        type: \"uint256\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"conduitKey\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"uint256\",\n        name: \"totalOriginalConsiderationItems\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct OrderParameters\",\n      name: \"parameters\",\n      type: \"tuple\"\n    }, {\n      internalType: \"bytes\",\n      name: \"signature\",\n      type: \"bytes\"\n    }],\n    internalType: \"struct Order[]\",\n    name: \"orders\",\n    type: \"tuple[]\"\n  }],\n  name: \"validate\",\n  outputs: [{\n    internalType: \"bool\",\n    name: \"validated\",\n    type: \"bool\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}];\nvar SeaportTrade = /*#__PURE__*/function (_NFTTrade) {\n  _inheritsLoose(SeaportTrade, _NFTTrade);\n  function SeaportTrade(orders) {\n    return _NFTTrade.call(this, exports.Market.Seaport, orders) || this;\n  }\n  var _proto = SeaportTrade.prototype;\n  _proto.encode = function encode(planner, config) {\n    for (var _iterator = _createForOfIteratorHelperLoose(this.orders), _step; !(_step = _iterator()).done;) {\n      var order = _step.value;\n      var advancedOrders = [];\n      var orderFulfillments = order.items.map(function (_, index) {\n        return [{\n          orderIndex: index,\n          itemIndex: 0\n        }];\n      });\n      var considerationFulFillments = this.getConsiderationFulfillments(order.items);\n      for (var _iterator2 = _createForOfIteratorHelperLoose(order.items), _step2; !(_step2 = _iterator2()).done;) {\n        var item = _step2.value;\n        var _this$getAdvancedOrde = this.getAdvancedOrderParams(item),\n          advancedOrder = _this$getAdvancedOrde.advancedOrder;\n        advancedOrders.push(advancedOrder);\n      }\n      var calldata = void 0;\n      if (advancedOrders.length == 1) {\n        calldata = SeaportTrade.INTERFACE.encodeFunctionData('fulfillAdvancedOrder', [advancedOrders[0], [], SeaportTrade.OPENSEA_CONDUIT_KEY, order.recipient]);\n      } else {\n        calldata = SeaportTrade.INTERFACE.encodeFunctionData('fulfillAvailableAdvancedOrders', [advancedOrders, [], orderFulfillments, considerationFulFillments, SeaportTrade.OPENSEA_CONDUIT_KEY, order.recipient, 100]);\n      }\n      planner.addCommand(CommandType.SEAPORT, [this.getTotalPrice().toString(), calldata], config.allowRevert);\n    }\n  };\n  _proto.getBuyItems = function getBuyItems() {\n    var buyItems = [];\n    for (var _iterator3 = _createForOfIteratorHelperLoose(this.orders), _step3; !(_step3 = _iterator3()).done;) {\n      var order = _step3.value;\n      for (var _iterator4 = _createForOfIteratorHelperLoose(order.items), _step4; !(_step4 = _iterator4()).done;) {\n        var item = _step4.value;\n        for (var _iterator5 = _createForOfIteratorHelperLoose(item.parameters.offer), _step5; !(_step5 = _iterator5()).done;) {\n          var offer = _step5.value;\n          buyItems.push({\n            tokenAddress: offer.token,\n            tokenId: offer.identifierOrCriteria,\n            tokenType: exports.TokenType.ERC721\n          });\n        }\n      }\n    }\n    return buyItems;\n  };\n  _proto.getTotalPrice = function getTotalPrice() {\n    var totalPrice = ethers.BigNumber.from(0);\n    for (var _iterator6 = _createForOfIteratorHelperLoose(this.orders), _step6; !(_step6 = _iterator6()).done;) {\n      var order = _step6.value;\n      for (var _iterator7 = _createForOfIteratorHelperLoose(order.items), _step7; !(_step7 = _iterator7()).done;) {\n        var item = _step7.value;\n        totalPrice = totalPrice.add(this.calculateValue(item.parameters.consideration));\n      }\n    }\n    return totalPrice;\n  };\n  _proto.getConsiderationFulfillments = function getConsiderationFulfillments(protocolDatas) {\n    var considerationFulfillments = [];\n    var considerationRecipients = [];\n    for (var i in protocolDatas) {\n      var protocolData = protocolDatas[i];\n      var _loop = function _loop(j) {\n        var item = protocolData.parameters.consideration[j];\n        if (considerationRecipients.findIndex(function (x) {\n          return x === item.recipient;\n        }) === -1) {\n          considerationRecipients.push(item.recipient);\n        }\n        var recipientIndex = considerationRecipients.findIndex(function (x) {\n          return x === item.recipient;\n        });\n        if (!considerationFulfillments[recipientIndex]) {\n          considerationFulfillments.push([{\n            orderIndex: i,\n            itemIndex: j\n          }]);\n        } else {\n          considerationFulfillments[recipientIndex].push({\n            orderIndex: i,\n            itemIndex: j\n          });\n        }\n      };\n      for (var j in protocolData.parameters.consideration) {\n        _loop(j);\n      }\n    }\n    return considerationFulfillments;\n  };\n  _proto.getAdvancedOrderParams = function getAdvancedOrderParams(data) {\n    var advancedOrder = {\n      parameters: data.parameters,\n      numerator: ethers.BigNumber.from('1'),\n      denominator: ethers.BigNumber.from('1'),\n      signature: data.signature,\n      extraData: '0x00'\n    };\n    var value = this.calculateValue(data.parameters.consideration);\n    return {\n      advancedOrder: advancedOrder,\n      value: value\n    };\n  };\n  _proto.calculateValue = function calculateValue(considerations) {\n    return considerations.reduce(function (amt, consideration) {\n      return amt.add(consideration.startAmount);\n    }, ethers.BigNumber.from(0));\n  };\n  return SeaportTrade;\n}(NFTTrade);\nSeaportTrade.INTERFACE = /*#__PURE__*/new abi$7.Interface(abi$4);\nSeaportTrade.OPENSEA_CONDUIT_KEY = '0x0000007b02230091a7ed01230072f7006a004d60a8d4e71d599b8104250f0000';\nvar abi$5 = [{\n  inputs: [{\n    internalType: \"contract ILSSVMPairFactoryLike\",\n    name: \"_factory\",\n    type: \"address\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"constructor\"\n}, {\n  inputs: [],\n  name: \"factory\",\n  outputs: [{\n    internalType: \"contract ILSSVMPairFactoryLike\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"contract ERC20\",\n    name: \"token\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"from\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }, {\n    internalType: \"enum ILSSVMPairFactoryLike.PairVariant\",\n    name: \"variant\",\n    type: \"uint8\"\n  }],\n  name: \"pairTransferERC20From\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"contract IERC721\",\n    name: \"nft\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"from\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"id\",\n    type: \"uint256\"\n  }, {\n    internalType: \"enum ILSSVMPairFactoryLike.PairVariant\",\n    name: \"variant\",\n    type: \"uint8\"\n  }],\n  name: \"pairTransferNFTFrom\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"contract LSSVMPair\",\n        name: \"pair\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256\",\n        name: \"numItems\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct LSSVMRouter.PairSwapAny\",\n      name: \"swapInfo\",\n      type: \"tuple\"\n    }, {\n      internalType: \"uint256\",\n      name: \"maxCost\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct LSSVMRouter.RobustPairSwapAny[]\",\n    name: \"swapList\",\n    type: \"tuple[]\"\n  }, {\n    internalType: \"uint256\",\n    name: \"inputAmount\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address\",\n    name: \"nftRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"deadline\",\n    type: \"uint256\"\n  }],\n  name: \"robustSwapERC20ForAnyNFTs\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"remainingValue\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"contract LSSVMPair\",\n        name: \"pair\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256[]\",\n        name: \"nftIds\",\n        type: \"uint256[]\"\n      }],\n      internalType: \"struct LSSVMRouter.PairSwapSpecific\",\n      name: \"swapInfo\",\n      type: \"tuple\"\n    }, {\n      internalType: \"uint256\",\n      name: \"maxCost\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct LSSVMRouter.RobustPairSwapSpecific[]\",\n    name: \"swapList\",\n    type: \"tuple[]\"\n  }, {\n    internalType: \"uint256\",\n    name: \"inputAmount\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address\",\n    name: \"nftRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"deadline\",\n    type: \"uint256\"\n  }],\n  name: \"robustSwapERC20ForSpecificNFTs\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"remainingValue\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        components: [{\n          internalType: \"contract LSSVMPair\",\n          name: \"pair\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256[]\",\n          name: \"nftIds\",\n          type: \"uint256[]\"\n        }],\n        internalType: \"struct LSSVMRouter.PairSwapSpecific\",\n        name: \"swapInfo\",\n        type: \"tuple\"\n      }, {\n        internalType: \"uint256\",\n        name: \"maxCost\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct LSSVMRouter.RobustPairSwapSpecific[]\",\n      name: \"tokenToNFTTrades\",\n      type: \"tuple[]\"\n    }, {\n      components: [{\n        components: [{\n          internalType: \"contract LSSVMPair\",\n          name: \"pair\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256[]\",\n          name: \"nftIds\",\n          type: \"uint256[]\"\n        }],\n        internalType: \"struct LSSVMRouter.PairSwapSpecific\",\n        name: \"swapInfo\",\n        type: \"tuple\"\n      }, {\n        internalType: \"uint256\",\n        name: \"minOutput\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct LSSVMRouter.RobustPairSwapSpecificForToken[]\",\n      name: \"nftToTokenTrades\",\n      type: \"tuple[]\"\n    }, {\n      internalType: \"uint256\",\n      name: \"inputAmount\",\n      type: \"uint256\"\n    }, {\n      internalType: \"address payable\",\n      name: \"tokenRecipient\",\n      type: \"address\"\n    }, {\n      internalType: \"address\",\n      name: \"nftRecipient\",\n      type: \"address\"\n    }],\n    internalType: \"struct LSSVMRouter.RobustPairNFTsFoTokenAndTokenforNFTsTrade\",\n    name: \"params\",\n    type: \"tuple\"\n  }],\n  name: \"robustSwapERC20ForSpecificNFTsAndNFTsToToken\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"remainingValue\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"outputAmount\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"contract LSSVMPair\",\n        name: \"pair\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256\",\n        name: \"numItems\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct LSSVMRouter.PairSwapAny\",\n      name: \"swapInfo\",\n      type: \"tuple\"\n    }, {\n      internalType: \"uint256\",\n      name: \"maxCost\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct LSSVMRouter.RobustPairSwapAny[]\",\n    name: \"swapList\",\n    type: \"tuple[]\"\n  }, {\n    internalType: \"address payable\",\n    name: \"ethRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"nftRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"deadline\",\n    type: \"uint256\"\n  }],\n  name: \"robustSwapETHForAnyNFTs\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"remainingValue\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"contract LSSVMPair\",\n        name: \"pair\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256[]\",\n        name: \"nftIds\",\n        type: \"uint256[]\"\n      }],\n      internalType: \"struct LSSVMRouter.PairSwapSpecific\",\n      name: \"swapInfo\",\n      type: \"tuple\"\n    }, {\n      internalType: \"uint256\",\n      name: \"maxCost\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct LSSVMRouter.RobustPairSwapSpecific[]\",\n    name: \"swapList\",\n    type: \"tuple[]\"\n  }, {\n    internalType: \"address payable\",\n    name: \"ethRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"nftRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"deadline\",\n    type: \"uint256\"\n  }],\n  name: \"robustSwapETHForSpecificNFTs\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"remainingValue\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        components: [{\n          internalType: \"contract LSSVMPair\",\n          name: \"pair\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256[]\",\n          name: \"nftIds\",\n          type: \"uint256[]\"\n        }],\n        internalType: \"struct LSSVMRouter.PairSwapSpecific\",\n        name: \"swapInfo\",\n        type: \"tuple\"\n      }, {\n        internalType: \"uint256\",\n        name: \"maxCost\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct LSSVMRouter.RobustPairSwapSpecific[]\",\n      name: \"tokenToNFTTrades\",\n      type: \"tuple[]\"\n    }, {\n      components: [{\n        components: [{\n          internalType: \"contract LSSVMPair\",\n          name: \"pair\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256[]\",\n          name: \"nftIds\",\n          type: \"uint256[]\"\n        }],\n        internalType: \"struct LSSVMRouter.PairSwapSpecific\",\n        name: \"swapInfo\",\n        type: \"tuple\"\n      }, {\n        internalType: \"uint256\",\n        name: \"minOutput\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct LSSVMRouter.RobustPairSwapSpecificForToken[]\",\n      name: \"nftToTokenTrades\",\n      type: \"tuple[]\"\n    }, {\n      internalType: \"uint256\",\n      name: \"inputAmount\",\n      type: \"uint256\"\n    }, {\n      internalType: \"address payable\",\n      name: \"tokenRecipient\",\n      type: \"address\"\n    }, {\n      internalType: \"address\",\n      name: \"nftRecipient\",\n      type: \"address\"\n    }],\n    internalType: \"struct LSSVMRouter.RobustPairNFTsFoTokenAndTokenforNFTsTrade\",\n    name: \"params\",\n    type: \"tuple\"\n  }],\n  name: \"robustSwapETHForSpecificNFTsAndNFTsToToken\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"remainingValue\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"outputAmount\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"contract LSSVMPair\",\n        name: \"pair\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256[]\",\n        name: \"nftIds\",\n        type: \"uint256[]\"\n      }],\n      internalType: \"struct LSSVMRouter.PairSwapSpecific\",\n      name: \"swapInfo\",\n      type: \"tuple\"\n    }, {\n      internalType: \"uint256\",\n      name: \"minOutput\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct LSSVMRouter.RobustPairSwapSpecificForToken[]\",\n    name: \"swapList\",\n    type: \"tuple[]\"\n  }, {\n    internalType: \"address payable\",\n    name: \"tokenRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"deadline\",\n    type: \"uint256\"\n  }],\n  name: \"robustSwapNFTsForToken\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"outputAmount\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      internalType: \"contract LSSVMPair\",\n      name: \"pair\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"numItems\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct LSSVMRouter.PairSwapAny[]\",\n    name: \"swapList\",\n    type: \"tuple[]\"\n  }, {\n    internalType: \"uint256\",\n    name: \"inputAmount\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address\",\n    name: \"nftRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"deadline\",\n    type: \"uint256\"\n  }],\n  name: \"swapERC20ForAnyNFTs\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"remainingValue\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      internalType: \"contract LSSVMPair\",\n      name: \"pair\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256[]\",\n      name: \"nftIds\",\n      type: \"uint256[]\"\n    }],\n    internalType: \"struct LSSVMRouter.PairSwapSpecific[]\",\n    name: \"swapList\",\n    type: \"tuple[]\"\n  }, {\n    internalType: \"uint256\",\n    name: \"inputAmount\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address\",\n    name: \"nftRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"deadline\",\n    type: \"uint256\"\n  }],\n  name: \"swapERC20ForSpecificNFTs\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"remainingValue\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      internalType: \"contract LSSVMPair\",\n      name: \"pair\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"numItems\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct LSSVMRouter.PairSwapAny[]\",\n    name: \"swapList\",\n    type: \"tuple[]\"\n  }, {\n    internalType: \"address payable\",\n    name: \"ethRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"nftRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"deadline\",\n    type: \"uint256\"\n  }],\n  name: \"swapETHForAnyNFTs\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"remainingValue\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      internalType: \"contract LSSVMPair\",\n      name: \"pair\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256[]\",\n      name: \"nftIds\",\n      type: \"uint256[]\"\n    }],\n    internalType: \"struct LSSVMRouter.PairSwapSpecific[]\",\n    name: \"swapList\",\n    type: \"tuple[]\"\n  }, {\n    internalType: \"address payable\",\n    name: \"ethRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"nftRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"deadline\",\n    type: \"uint256\"\n  }],\n  name: \"swapETHForSpecificNFTs\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"remainingValue\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"contract LSSVMPair\",\n        name: \"pair\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256[]\",\n        name: \"nftIds\",\n        type: \"uint256[]\"\n      }],\n      internalType: \"struct LSSVMRouter.PairSwapSpecific[]\",\n      name: \"nftToTokenTrades\",\n      type: \"tuple[]\"\n    }, {\n      components: [{\n        internalType: \"contract LSSVMPair\",\n        name: \"pair\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256\",\n        name: \"numItems\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct LSSVMRouter.PairSwapAny[]\",\n      name: \"tokenToNFTTrades\",\n      type: \"tuple[]\"\n    }],\n    internalType: \"struct LSSVMRouter.NFTsForAnyNFTsTrade\",\n    name: \"trade\",\n    type: \"tuple\"\n  }, {\n    internalType: \"uint256\",\n    name: \"inputAmount\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"minOutput\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address\",\n    name: \"nftRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"deadline\",\n    type: \"uint256\"\n  }],\n  name: \"swapNFTsForAnyNFTsThroughERC20\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"outputAmount\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"contract LSSVMPair\",\n        name: \"pair\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256[]\",\n        name: \"nftIds\",\n        type: \"uint256[]\"\n      }],\n      internalType: \"struct LSSVMRouter.PairSwapSpecific[]\",\n      name: \"nftToTokenTrades\",\n      type: \"tuple[]\"\n    }, {\n      components: [{\n        internalType: \"contract LSSVMPair\",\n        name: \"pair\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256\",\n        name: \"numItems\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct LSSVMRouter.PairSwapAny[]\",\n      name: \"tokenToNFTTrades\",\n      type: \"tuple[]\"\n    }],\n    internalType: \"struct LSSVMRouter.NFTsForAnyNFTsTrade\",\n    name: \"trade\",\n    type: \"tuple\"\n  }, {\n    internalType: \"uint256\",\n    name: \"minOutput\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address payable\",\n    name: \"ethRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"nftRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"deadline\",\n    type: \"uint256\"\n  }],\n  name: \"swapNFTsForAnyNFTsThroughETH\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"outputAmount\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"contract LSSVMPair\",\n        name: \"pair\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256[]\",\n        name: \"nftIds\",\n        type: \"uint256[]\"\n      }],\n      internalType: \"struct LSSVMRouter.PairSwapSpecific[]\",\n      name: \"nftToTokenTrades\",\n      type: \"tuple[]\"\n    }, {\n      components: [{\n        internalType: \"contract LSSVMPair\",\n        name: \"pair\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256[]\",\n        name: \"nftIds\",\n        type: \"uint256[]\"\n      }],\n      internalType: \"struct LSSVMRouter.PairSwapSpecific[]\",\n      name: \"tokenToNFTTrades\",\n      type: \"tuple[]\"\n    }],\n    internalType: \"struct LSSVMRouter.NFTsForSpecificNFTsTrade\",\n    name: \"trade\",\n    type: \"tuple\"\n  }, {\n    internalType: \"uint256\",\n    name: \"inputAmount\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"minOutput\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address\",\n    name: \"nftRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"deadline\",\n    type: \"uint256\"\n  }],\n  name: \"swapNFTsForSpecificNFTsThroughERC20\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"outputAmount\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"contract LSSVMPair\",\n        name: \"pair\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256[]\",\n        name: \"nftIds\",\n        type: \"uint256[]\"\n      }],\n      internalType: \"struct LSSVMRouter.PairSwapSpecific[]\",\n      name: \"nftToTokenTrades\",\n      type: \"tuple[]\"\n    }, {\n      components: [{\n        internalType: \"contract LSSVMPair\",\n        name: \"pair\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256[]\",\n        name: \"nftIds\",\n        type: \"uint256[]\"\n      }],\n      internalType: \"struct LSSVMRouter.PairSwapSpecific[]\",\n      name: \"tokenToNFTTrades\",\n      type: \"tuple[]\"\n    }],\n    internalType: \"struct LSSVMRouter.NFTsForSpecificNFTsTrade\",\n    name: \"trade\",\n    type: \"tuple\"\n  }, {\n    internalType: \"uint256\",\n    name: \"minOutput\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address payable\",\n    name: \"ethRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"nftRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"deadline\",\n    type: \"uint256\"\n  }],\n  name: \"swapNFTsForSpecificNFTsThroughETH\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"outputAmount\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      internalType: \"contract LSSVMPair\",\n      name: \"pair\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256[]\",\n      name: \"nftIds\",\n      type: \"uint256[]\"\n    }],\n    internalType: \"struct LSSVMRouter.PairSwapSpecific[]\",\n    name: \"swapList\",\n    type: \"tuple[]\"\n  }, {\n    internalType: \"uint256\",\n    name: \"minOutput\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address\",\n    name: \"tokenRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"deadline\",\n    type: \"uint256\"\n  }],\n  name: \"swapNFTsForToken\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"outputAmount\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  stateMutability: \"payable\",\n  type: \"receive\"\n}];\nvar SudoswapTrade = /*#__PURE__*/function (_NFTTrade) {\n  _inheritsLoose(SudoswapTrade, _NFTTrade);\n  function SudoswapTrade(orders) {\n    return _NFTTrade.call(this, exports.Market.Sudoswap, orders) || this;\n  }\n  var _proto = SudoswapTrade.prototype;\n  _proto.encode = function encode(planner, config) {\n    for (var _iterator = _createForOfIteratorHelperLoose(this.orders), _step; !(_step = _iterator()).done;) {\n      var order = _step.value;\n      var calldata = SudoswapTrade.INTERFACE.encodeFunctionData('robustSwapETHForSpecificNFTs', [order.swaps.map(function (swap) {\n        return {\n          swapInfo: swap.swapInfo,\n          maxCost: swap.maxCost\n        };\n      }), order.ethRecipient, order.nftRecipient, order.deadline]);\n      var value = order.swaps.reduce(function (prevVal, swap) {\n        return prevVal.add(swap.maxCost);\n      }, ethers.BigNumber.from(0));\n      planner.addCommand(CommandType.SUDOSWAP, [value, calldata], config.allowRevert);\n    }\n  };\n  _proto.getBuyItems = function getBuyItems() {\n    var buyItems = [];\n    for (var _iterator2 = _createForOfIteratorHelperLoose(this.orders), _step2; !(_step2 = _iterator2()).done;) {\n      var order = _step2.value;\n      for (var _iterator3 = _createForOfIteratorHelperLoose(order.swaps), _step3; !(_step3 = _iterator3()).done;) {\n        var swap = _step3.value;\n        for (var _iterator4 = _createForOfIteratorHelperLoose(swap.swapInfo.nftIds), _step4; !(_step4 = _iterator4()).done;) {\n          var tokenId = _step4.value;\n          buyItems.push({\n            tokenAddress: swap.tokenAddress,\n            tokenId: tokenId,\n            tokenType: exports.TokenType.ERC721\n          });\n        }\n      }\n    }\n    return buyItems;\n  };\n  _proto.getTotalPrice = function getTotalPrice() {\n    var total = ethers.BigNumber.from(0);\n    for (var _iterator5 = _createForOfIteratorHelperLoose(this.orders), _step5; !(_step5 = _iterator5()).done;) {\n      var order = _step5.value;\n      for (var _iterator6 = _createForOfIteratorHelperLoose(order.swaps), _step6; !(_step6 = _iterator6()).done;) {\n        var swap = _step6.value;\n        total = total.add(swap.maxCost);\n      }\n    }\n    return total;\n  };\n  return SudoswapTrade;\n}(NFTTrade);\nSudoswapTrade.INTERFACE = /*#__PURE__*/new abi$7.Interface(abi$5);\nvar abi$6 = [{\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"bytes32\",\n    name: \"itemHash\",\n    type: \"bytes32\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"currency\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"incentive\",\n    type: \"uint256\"\n  }],\n  name: \"EvAuctionRefund\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"bytes32\",\n    name: \"itemHash\",\n    type: \"bytes32\"\n  }],\n  name: \"EvCancel\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"address\",\n    name: \"delegate\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"bool\",\n    name: \"isRemoval\",\n    type: \"bool\"\n  }],\n  name: \"EvDelegate\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"index\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"bytes\",\n    name: \"error\",\n    type: \"bytes\"\n  }],\n  name: \"EvFailure\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"newValue\",\n    type: \"uint256\"\n  }],\n  name: \"EvFeeCapUpdate\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"bytes32\",\n    name: \"itemHash\",\n    type: \"bytes32\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"maker\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"taker\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"orderSalt\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"settleSalt\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"intent\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"delegateType\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"deadline\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"contract IERC20Upgradeable\",\n    name: \"currency\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"bytes\",\n    name: \"dataMask\",\n    type: \"bytes\"\n  }, {\n    components: [{\n      internalType: \"uint256\",\n      name: \"price\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes\",\n      name: \"data\",\n      type: \"bytes\"\n    }],\n    indexed: false,\n    internalType: \"struct Market.OrderItem\",\n    name: \"item\",\n    type: \"tuple\"\n  }, {\n    components: [{\n      internalType: \"enum Market.Op\",\n      name: \"op\",\n      type: \"uint8\"\n    }, {\n      internalType: \"uint256\",\n      name: \"orderIdx\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"itemIdx\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"price\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"itemHash\",\n      type: \"bytes32\"\n    }, {\n      internalType: \"contract IDelegate\",\n      name: \"executionDelegate\",\n      type: \"address\"\n    }, {\n      internalType: \"bytes\",\n      name: \"dataReplacement\",\n      type: \"bytes\"\n    }, {\n      internalType: \"uint256\",\n      name: \"bidIncentivePct\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"aucMinIncrementPct\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"aucIncDurationSecs\",\n      type: \"uint256\"\n    }, {\n      components: [{\n        internalType: \"uint256\",\n        name: \"percentage\",\n        type: \"uint256\"\n      }, {\n        internalType: \"address\",\n        name: \"to\",\n        type: \"address\"\n      }],\n      internalType: \"struct Market.Fee[]\",\n      name: \"fees\",\n      type: \"tuple[]\"\n    }],\n    indexed: false,\n    internalType: \"struct Market.SettleDetail\",\n    name: \"detail\",\n    type: \"tuple\"\n  }],\n  name: \"EvInventory\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"bytes32\",\n    name: \"itemHash\",\n    type: \"bytes32\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"currency\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }],\n  name: \"EvProfit\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"address\",\n    name: \"signer\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"bool\",\n    name: \"isRemoval\",\n    type: \"bool\"\n  }],\n  name: \"EvSigner\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"previousOwner\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"newOwner\",\n    type: \"address\"\n  }],\n  name: \"OwnershipTransferred\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"address\",\n    name: \"account\",\n    type: \"address\"\n  }],\n  name: \"Paused\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"address\",\n    name: \"account\",\n    type: \"address\"\n  }],\n  name: \"Unpaused\",\n  type: \"event\"\n}, {\n  inputs: [],\n  name: \"RATE_BASE\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"bytes32[]\",\n    name: \"itemHashes\",\n    type: \"bytes32[]\"\n  }, {\n    internalType: \"uint256\",\n    name: \"deadline\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint8\",\n    name: \"v\",\n    type: \"uint8\"\n  }, {\n    internalType: \"bytes32\",\n    name: \"r\",\n    type: \"bytes32\"\n  }, {\n    internalType: \"bytes32\",\n    name: \"s\",\n    type: \"bytes32\"\n  }],\n  name: \"cancel\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }],\n  name: \"delegates\",\n  outputs: [{\n    internalType: \"bool\",\n    name: \"\",\n    type: \"bool\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"feeCapPct\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"feeCapPct_\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address\",\n    name: \"weth_\",\n    type: \"address\"\n  }],\n  name: \"initialize\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"bytes32\",\n    name: \"\",\n    type: \"bytes32\"\n  }],\n  name: \"inventoryStatus\",\n  outputs: [{\n    internalType: \"enum Market.InvStatus\",\n    name: \"\",\n    type: \"uint8\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"bytes32\",\n    name: \"\",\n    type: \"bytes32\"\n  }],\n  name: \"ongoingAuctions\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"price\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"netPrice\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"endAt\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address\",\n    name: \"bidder\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"owner\",\n  outputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"pause\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"paused\",\n  outputs: [{\n    internalType: \"bool\",\n    name: \"\",\n    type: \"bool\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"renounceOwnership\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"uint256\",\n        name: \"salt\",\n        type: \"uint256\"\n      }, {\n        internalType: \"address\",\n        name: \"user\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256\",\n        name: \"network\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"intent\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"delegateType\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"deadline\",\n        type: \"uint256\"\n      }, {\n        internalType: \"contract IERC20Upgradeable\",\n        name: \"currency\",\n        type: \"address\"\n      }, {\n        internalType: \"bytes\",\n        name: \"dataMask\",\n        type: \"bytes\"\n      }, {\n        components: [{\n          internalType: \"uint256\",\n          name: \"price\",\n          type: \"uint256\"\n        }, {\n          internalType: \"bytes\",\n          name: \"data\",\n          type: \"bytes\"\n        }],\n        internalType: \"struct Market.OrderItem[]\",\n        name: \"items\",\n        type: \"tuple[]\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"r\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"s\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"uint8\",\n        name: \"v\",\n        type: \"uint8\"\n      }, {\n        internalType: \"uint8\",\n        name: \"signVersion\",\n        type: \"uint8\"\n      }],\n      internalType: \"struct Market.Order[]\",\n      name: \"orders\",\n      type: \"tuple[]\"\n    }, {\n      components: [{\n        internalType: \"enum Market.Op\",\n        name: \"op\",\n        type: \"uint8\"\n      }, {\n        internalType: \"uint256\",\n        name: \"orderIdx\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"itemIdx\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"price\",\n        type: \"uint256\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"itemHash\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"contract IDelegate\",\n        name: \"executionDelegate\",\n        type: \"address\"\n      }, {\n        internalType: \"bytes\",\n        name: \"dataReplacement\",\n        type: \"bytes\"\n      }, {\n        internalType: \"uint256\",\n        name: \"bidIncentivePct\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"aucMinIncrementPct\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"aucIncDurationSecs\",\n        type: \"uint256\"\n      }, {\n        components: [{\n          internalType: \"uint256\",\n          name: \"percentage\",\n          type: \"uint256\"\n        }, {\n          internalType: \"address\",\n          name: \"to\",\n          type: \"address\"\n        }],\n        internalType: \"struct Market.Fee[]\",\n        name: \"fees\",\n        type: \"tuple[]\"\n      }],\n      internalType: \"struct Market.SettleDetail[]\",\n      name: \"details\",\n      type: \"tuple[]\"\n    }, {\n      components: [{\n        internalType: \"uint256\",\n        name: \"salt\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"deadline\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"amountToEth\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"amountToWeth\",\n        type: \"uint256\"\n      }, {\n        internalType: \"address\",\n        name: \"user\",\n        type: \"address\"\n      }, {\n        internalType: \"bool\",\n        name: \"canFail\",\n        type: \"bool\"\n      }],\n      internalType: \"struct Market.SettleShared\",\n      name: \"shared\",\n      type: \"tuple\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"r\",\n      type: \"bytes32\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"s\",\n      type: \"bytes32\"\n    }, {\n      internalType: \"uint8\",\n      name: \"v\",\n      type: \"uint8\"\n    }],\n    internalType: \"struct Market.RunInput\",\n    name: \"input\",\n    type: \"tuple\"\n  }],\n  name: \"run\",\n  outputs: [],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      internalType: \"uint256\",\n      name: \"salt\",\n      type: \"uint256\"\n    }, {\n      internalType: \"address\",\n      name: \"user\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"network\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"intent\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"delegateType\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"deadline\",\n      type: \"uint256\"\n    }, {\n      internalType: \"contract IERC20Upgradeable\",\n      name: \"currency\",\n      type: \"address\"\n    }, {\n      internalType: \"bytes\",\n      name: \"dataMask\",\n      type: \"bytes\"\n    }, {\n      components: [{\n        internalType: \"uint256\",\n        name: \"price\",\n        type: \"uint256\"\n      }, {\n        internalType: \"bytes\",\n        name: \"data\",\n        type: \"bytes\"\n      }],\n      internalType: \"struct Market.OrderItem[]\",\n      name: \"items\",\n      type: \"tuple[]\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"r\",\n      type: \"bytes32\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"s\",\n      type: \"bytes32\"\n    }, {\n      internalType: \"uint8\",\n      name: \"v\",\n      type: \"uint8\"\n    }, {\n      internalType: \"uint8\",\n      name: \"signVersion\",\n      type: \"uint8\"\n    }],\n    internalType: \"struct Market.Order\",\n    name: \"order\",\n    type: \"tuple\"\n  }, {\n    components: [{\n      internalType: \"uint256\",\n      name: \"salt\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"deadline\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"amountToEth\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"amountToWeth\",\n      type: \"uint256\"\n    }, {\n      internalType: \"address\",\n      name: \"user\",\n      type: \"address\"\n    }, {\n      internalType: \"bool\",\n      name: \"canFail\",\n      type: \"bool\"\n    }],\n    internalType: \"struct Market.SettleShared\",\n    name: \"shared\",\n    type: \"tuple\"\n  }, {\n    components: [{\n      internalType: \"enum Market.Op\",\n      name: \"op\",\n      type: \"uint8\"\n    }, {\n      internalType: \"uint256\",\n      name: \"orderIdx\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"itemIdx\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"price\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"itemHash\",\n      type: \"bytes32\"\n    }, {\n      internalType: \"contract IDelegate\",\n      name: \"executionDelegate\",\n      type: \"address\"\n    }, {\n      internalType: \"bytes\",\n      name: \"dataReplacement\",\n      type: \"bytes\"\n    }, {\n      internalType: \"uint256\",\n      name: \"bidIncentivePct\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"aucMinIncrementPct\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"aucIncDurationSecs\",\n      type: \"uint256\"\n    }, {\n      components: [{\n        internalType: \"uint256\",\n        name: \"percentage\",\n        type: \"uint256\"\n      }, {\n        internalType: \"address\",\n        name: \"to\",\n        type: \"address\"\n      }],\n      internalType: \"struct Market.Fee[]\",\n      name: \"fees\",\n      type: \"tuple[]\"\n    }],\n    internalType: \"struct Market.SettleDetail\",\n    name: \"detail\",\n    type: \"tuple\"\n  }],\n  name: \"run1\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }],\n  name: \"signers\",\n  outputs: [{\n    internalType: \"bool\",\n    name: \"\",\n    type: \"bool\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"newOwner\",\n    type: \"address\"\n  }],\n  name: \"transferOwnership\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"unpause\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address[]\",\n    name: \"toAdd\",\n    type: \"address[]\"\n  }, {\n    internalType: \"address[]\",\n    name: \"toRemove\",\n    type: \"address[]\"\n  }],\n  name: \"updateDelegates\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"val\",\n    type: \"uint256\"\n  }],\n  name: \"updateFeeCap\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address[]\",\n    name: \"toAdd\",\n    type: \"address[]\"\n  }, {\n    internalType: \"address[]\",\n    name: \"toRemove\",\n    type: \"address[]\"\n  }],\n  name: \"updateSigners\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"weth\",\n  outputs: [{\n    internalType: \"contract IWETHUpgradable\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  stateMutability: \"payable\",\n  type: \"receive\"\n}];\nvar X2Y2Trade = /*#__PURE__*/function (_NFTTrade) {\n  _inheritsLoose(X2Y2Trade, _NFTTrade);\n  function X2Y2Trade(orders) {\n    return _NFTTrade.call(this, exports.Market.X2Y2, orders) || this;\n  }\n  var _proto = X2Y2Trade.prototype;\n  _proto.encode = function encode(planner, config) {\n    for (var _iterator = _createForOfIteratorHelperLoose(this.orders), _step; !(_step = _iterator()).done;) {\n      var item = _step.value;\n      var functionSelector = X2Y2Trade.INTERFACE.getSighash(X2Y2Trade.INTERFACE.getFunction('run'));\n      var calldata = functionSelector + item.signedInput.slice(2);\n      if (item.tokenType == exports.TokenType.ERC721) {\n        planner.addCommand(CommandType.X2Y2_721, [item.price, calldata, item.recipient, item.tokenAddress, item.tokenId], config.allowRevert);\n      } else if (item.tokenType == exports.TokenType.ERC1155) {\n        planner.addCommand(CommandType.X2Y2_1155, [item.price, calldata, item.recipient, item.tokenAddress, item.tokenId, item.tokenAmount], config.allowRevert);\n      }\n    }\n  };\n  _proto.getBuyItems = function getBuyItems() {\n    var buyItems = [];\n    for (var _iterator2 = _createForOfIteratorHelperLoose(this.orders), _step2; !(_step2 = _iterator2()).done;) {\n      var item = _step2.value;\n      buyItems.push({\n        tokenAddress: item.tokenAddress,\n        tokenId: item.tokenId,\n        tokenType: item.tokenType\n      });\n    }\n    return buyItems;\n  };\n  _proto.getTotalPrice = function getTotalPrice() {\n    var total = ethers.BigNumber.from(0);\n    for (var _iterator3 = _createForOfIteratorHelperLoose(this.orders), _step3; !(_step3 = _iterator3()).done;) {\n      var item = _step3.value;\n      total = total.add(item.price);\n    }\n    return total;\n  };\n  return X2Y2Trade;\n}(NFTTrade);\nX2Y2Trade.INTERFACE = /*#__PURE__*/new abi$7.Interface(abi$6);\nvar UnwrapWETH = /*#__PURE__*/function () {\n  function UnwrapWETH(amount, chainId, permit2) {\n    this.tradeType = exports.RouterTradeType.UnwrapWETH;\n    this.wethAddress = WETH_ADDRESS(chainId);\n    this.routerAddress = UNIVERSAL_ROUTER_ADDRESS(chainId);\n    this.amount = amount;\n    if (!!permit2) {\n      !(permit2.details.token === this.wethAddress) ? invariant(false, \"must be permitting WETH address: \" + this.wethAddress) : void 0;\n      !(permit2.details.amount >= amount) ? invariant(false, \"Did not permit enough WETH for unwrapWETH transaction\") : void 0;\n      this.permit2Data = permit2;\n    }\n  }\n  var _proto = UnwrapWETH.prototype;\n  _proto.encode = function encode(planner, _) {\n    if (!!this.permit2Data) encodePermit(planner, this.permit2Data);\n    planner.addCommand(CommandType.PERMIT2_TRANSFER_FROM, [this.wethAddress, this.routerAddress, this.amount]);\n    planner.addCommand(CommandType.UNWRAP_WETH, [ROUTER_AS_RECIPIENT, this.amount]);\n  };\n  return UnwrapWETH;\n}();\nexports.CryptopunkTrade = CryptopunkTrade;\nexports.FoundationTrade = FoundationTrade;\nexports.LooksRareTrade = LooksRareTrade;\nexports.NFT20Trade = NFT20Trade;\nexports.NFTTrade = NFTTrade;\nexports.NFTXTrade = NFTXTrade;\nexports.PERMIT2_ADDRESS = PERMIT2_ADDRESS;\nexports.ROUTER_AS_RECIPIENT = ROUTER_AS_RECIPIENT;\nexports.SeaportTrade = SeaportTrade;\nexports.SudoswapTrade = SudoswapTrade;\nexports.SwapRouter = SwapRouter;\nexports.UNIVERSAL_ROUTER_ADDRESS = UNIVERSAL_ROUTER_ADDRESS;\nexports.UniswapTrade = UniswapTrade;\nexports.UnwrapWETH = UnwrapWETH;\nexports.WETH_ADDRESS = WETH_ADDRESS;\nexports.X2Y2Trade = X2Y2Trade;","map":{"version":3,"sources":["../src/entities/Command.ts","../src/utils/routerCommands.ts","../src/utils/constants.ts","../src/entities/protocols/uniswap.ts","../src/utils/permit2.ts","../src/swapRouter.ts","../src/entities/NFTTrade.ts","../src/entities/protocols/cryptopunk.ts","../src/entities/protocols/foundation.ts","../src/entities/protocols/looksRare.ts","../src/entities/protocols/nft20.ts","../src/entities/protocols/nftx.ts","../src/entities/protocols/seaport.ts","../src/entities/protocols/sudoswap.ts","../src/entities/protocols/x2y2.ts","../src/entities/protocols/unwrapWETH.ts"],"names":["RouterTradeType","CommandType","PERMIT_STRUCT","PERMIT_BATCH_STRUCT","ALLOW_REVERT_FLAG","REVERTABLE_COMMANDS","Set","SEAPORT","NFTX","LOOKS_RARE_721","LOOKS_RARE_1155","X2Y2_721","X2Y2_1155","FOUNDATION","SUDOSWAP","NFT20","CRYPTOPUNKS","ABI_DEFINITION","PERMIT","PERMIT2_PERMIT_BATCH","PERMIT2_TRANSFER_FROM","PERMIT2_TRANSFER_FROM_BATCH","TRANSFER","V3_SWAP_EXACT_IN","V3_SWAP_EXACT_OUT","V2_SWAP_EXACT_IN","V2_SWAP_EXACT_OUT","WRAP_ETH","UNWRAP_WETH","SWEEP","PAY_PORTION","OWNER_CHECK_721","OWNER_CHECK_1155","RoutePlanner","commands","inputs","addCommand","type","parameters","allowRevert","command","createCommand","push","encodedInput","has","Error","concat","toString","padStart","defaultAbiCoder","encode","UNIVERSAL_ROUTER_ADDRESS","chainId","WETH_ADDRESS","PERMIT2_ADDRESS","CONTRACT_BALANCE","BigNumber","from","pow","ETH_ADDRESS","SENDER_AS_RECIPIENT","ROUTER_AS_RECIPIENT","REFUND_ETH_PRICE_IMPACT_THRESHOLD","Percent","JSBI","BigInt","UniswapTrade","planner","_config","payerIsUser","trade","inputAmount","currency","isNative","maximumAmountIn","options","slippageTolerance","quotient","recipient","performAggregatedSlippageCheck","tradeType","TradeType","EXACT_INPUT","routes","length","outputIsNative","outputAmount","inputIsNative","routerMustCustody","swap","swaps","route","protocol","Protocol","V2","addV2Swap","V3","addV3Swap","MIXED","addMixedSwap","minimumAmountOut","wrapped","address","EXACT_OUTPUT","riskOfPartialFill","V2Trade","path","map","pool","V3Trade","createUncheckedTrade","encodeRouteToPath","tradeRecipient","pools","Pool","Pair","MixedRouteTrade","amountIn","amountOut","sections","partitionMixedRouteByProtocol","isLastSectionInRoute","i","outputToken","inputToken","input","section","getOutputOfPools","newRouteOriginal","MixedRouteSDK","token0","equals","token1","newRoute","MixedRoute","mixedRouteIsAllV3","every","encodeMixedRouteToPath","liquidityToken","priceImpact","greaterThan","SIGNATURE_LENGTH","EIP_2098_SIGNATURE_LENGTH","encodePermit","permit","signature","ethers","utils","arrayify","joinSignature","splitSignature","SwapRouter","Interface","abi","swapCallParameters","trades","config","Array","isArray","nftTrades","filter","_","hasOwnProperty","orders","currentNativeValueInRouter","transactionValue","NFTTrade","nftTrade","tradePrice","getTotalPrice","lt","add","sub","uniswapTrade","swapOptions","inputTokenPermit","UnwrapWETH","amount","encodePlan","swapNFTCallParameters","totalPrice","swapERC20CallParameters","inputCurrency","nativeCurrencyValue","deadline","deadlineOrPreviousBlockhash","undefined","functionSignature","calldata","INTERFACE","encodeFunctionData","value","toHexString","market","Market","TokenType","CryptopunkTrade","Cryptopunks","item","tokenId","getBuyItems","buyItems","tokenAddress","CRYPTOPUNK_ADDRESS","tokenType","Cryptopunk","total","FoundationTrade","Foundation","price","referrer","ERC721","LooksRareTrade","LooksRare","takerOrder","makerOrder","collection","ERC1155","NFT20Trade","order","tokenIds","tokenAmounts","fee","isV3","NFTXTrade","vaultId","Ether","onChain","vaultAddress","SeaportTrade","Seaport","advancedOrders","orderFulfillments","items","index","orderIndex","itemIndex","considerationFulFillments","getConsiderationFulfillments","advancedOrder","getAdvancedOrderParams","OPENSEA_CONDUIT_KEY","offer","token","identifierOrCriteria","calculateValue","consideration","protocolDatas","considerationFulfillments","considerationRecipients","protocolData","j","findIndex","x","recipientIndex","data","numerator","denominator","extraData","considerations","reduce","amt","startAmount","SudoswapTrade","Sudoswap","swapInfo","maxCost","ethRecipient","nftRecipient","prevVal","nftIds","X2Y2Trade","X2Y2","functionSelector","getSighash","getFunction","signedInput","slice","tokenAmount","permit2","wethAddress","routerAddress","details","permit2Data"],"mappings":"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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ICoC5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","sourcesContent":["import { RoutePlanner } from '../utils/routerCommands'\n\nexport type TradeConfig = {\n  allowRevert: boolean\n}\n\nexport enum RouterTradeType {\n  UniswapTrade = 'UniswapTrade',\n  NFTTrade = 'NFTTrade',\n  UnwrapWETH = 'UnwrapWETH',\n}\n\n// interface for entities that can be encoded as a Universal Router command\nexport interface Command {\n  tradeType: RouterTradeType\n  encode(planner: RoutePlanner, config: TradeConfig): void\n}\n","import { defaultAbiCoder } from 'ethers/lib/utils'\n\n/**\n * CommandTypes\n * @description Flags that modify a command's execution\n * @enum {number}\n */\nexport enum CommandType {\n  V3_SWAP_EXACT_IN = 0x00,\n  V3_SWAP_EXACT_OUT = 0x01,\n  PERMIT2_TRANSFER_FROM = 0x02,\n  PERMIT2_PERMIT_BATCH = 0x03,\n  SWEEP = 0x04,\n  TRANSFER = 0x05,\n  PAY_PORTION = 0x06,\n\n  V2_SWAP_EXACT_IN = 0x08,\n  V2_SWAP_EXACT_OUT = 0x09,\n  PERMIT = 0x0a,\n  WRAP_ETH = 0x0b,\n  UNWRAP_WETH = 0x0c,\n  PERMIT2_TRANSFER_FROM_BATCH = 0x0d,\n\n  // NFT-related command types\n  SEAPORT = 0x10,\n  LOOKS_RARE_721 = 0x11,\n  NFTX = 0x12,\n  CRYPTOPUNKS = 0x13,\n  LOOKS_RARE_1155 = 0x14,\n  OWNER_CHECK_721 = 0x15,\n  OWNER_CHECK_1155 = 0x16,\n\n  X2Y2_721 = 0x18,\n  SUDOSWAP = 0x19,\n  NFT20 = 0x1a,\n  X2Y2_1155 = 0x1b,\n  FOUNDATION = 0x1c,\n}\n\nconst PERMIT_STRUCT =\n  '((address token,uint160 amount,uint48 expiration,uint48 nonce) details, address spender, uint256 sigDeadline)'\n\nconst PERMIT_BATCH_STRUCT =\n  '((address token,uint160 amount,uint48 expiration,uint48 nonce)[] details, address spender, uint256 sigDeadline)'\n\nconst ALLOW_REVERT_FLAG = 0x80\n\nconst REVERTABLE_COMMANDS = new Set<CommandType>([\n  CommandType.SEAPORT,\n  CommandType.NFTX,\n  CommandType.LOOKS_RARE_721,\n  CommandType.LOOKS_RARE_1155,\n  CommandType.X2Y2_721,\n  CommandType.X2Y2_1155,\n  CommandType.FOUNDATION,\n  CommandType.SUDOSWAP,\n  CommandType.NFT20,\n  CommandType.CRYPTOPUNKS,\n])\n\nconst ABI_DEFINITION: { [key in CommandType]: string[] } = {\n  [CommandType.PERMIT]: [PERMIT_STRUCT, 'bytes'],\n  [CommandType.PERMIT2_PERMIT_BATCH]: [PERMIT_BATCH_STRUCT, 'bytes'],\n  [CommandType.PERMIT2_TRANSFER_FROM]: ['address', 'address', 'uint160'],\n  [CommandType.PERMIT2_TRANSFER_FROM_BATCH]: ['bytes'],\n  [CommandType.TRANSFER]: ['address', 'address', 'uint256'],\n  [CommandType.V3_SWAP_EXACT_IN]: ['address', 'uint256', 'uint256', 'bytes', 'bool'],\n  [CommandType.V3_SWAP_EXACT_OUT]: ['address', 'uint256', 'uint256', 'bytes', 'bool'],\n  [CommandType.V2_SWAP_EXACT_IN]: ['address', 'uint256', 'uint256', 'address[]', 'bool'],\n  [CommandType.V2_SWAP_EXACT_OUT]: ['address', 'uint256', 'uint256', 'address[]', 'bool'],\n  [CommandType.SEAPORT]: ['uint256', 'bytes'],\n  [CommandType.WRAP_ETH]: ['address', 'uint256'],\n  [CommandType.UNWRAP_WETH]: ['address', 'uint256'],\n  [CommandType.SWEEP]: ['address', 'address', 'uint256'],\n  [CommandType.NFTX]: ['uint256', 'bytes'],\n  [CommandType.LOOKS_RARE_721]: ['uint256', 'bytes', 'address', 'address', 'uint256'],\n  [CommandType.LOOKS_RARE_1155]: ['uint256', 'bytes', 'address', 'address', 'uint256', 'uint256'],\n  [CommandType.X2Y2_721]: ['uint256', 'bytes', 'address', 'address', 'uint256'],\n  [CommandType.X2Y2_1155]: ['uint256', 'bytes', 'address', 'address', 'uint256', 'uint256'],\n  [CommandType.FOUNDATION]: ['uint256', 'bytes', 'address', 'address', 'uint256'],\n  [CommandType.PAY_PORTION]: ['address', 'address', 'uint256'],\n  [CommandType.SUDOSWAP]: ['uint256', 'bytes'],\n  [CommandType.OWNER_CHECK_721]: ['address', 'address', 'uint256'],\n  [CommandType.OWNER_CHECK_1155]: ['address', 'address', 'uint256', 'uint256'],\n  [CommandType.NFT20]: ['uint256', 'bytes'],\n  [CommandType.CRYPTOPUNKS]: ['uint256', 'address', 'uint256'],\n}\n\nexport class RoutePlanner {\n  commands: string\n  inputs: string[]\n\n  constructor() {\n    this.commands = '0x'\n    this.inputs = []\n  }\n\n  addCommand(type: CommandType, parameters: any[], allowRevert = false): void {\n    let command = createCommand(type, parameters)\n    this.inputs.push(command.encodedInput)\n    if (allowRevert) {\n      if (!REVERTABLE_COMMANDS.has(command.type)) {\n        throw new Error(`command type: ${command.type} cannot be allowed to revert`)\n      }\n      command.type = command.type | ALLOW_REVERT_FLAG\n    }\n\n    this.commands = this.commands.concat(command.type.toString(16).padStart(2, '0'))\n  }\n}\n\nexport type RouterCommand = {\n  type: CommandType\n  encodedInput: string\n}\n\nexport function createCommand(type: CommandType, parameters: any[]): RouterCommand {\n  const encodedInput = defaultAbiCoder.encode(ABI_DEFINITION[type], parameters)\n  return { type, encodedInput }\n}\n","import { BigNumber } from 'ethers'\n\nexport const UNIVERSAL_ROUTER_ADDRESS = (chainId: number): string => {\n  switch (chainId) {\n    case 1: // mainnet\n      return '0xEf1c6E67703c7BD7107eed8303Fbe6EC2554BF6B'\n    case 5: // goerli\n      return '0x4648a43B2C14Da09FdF82B161150d3F634f40491'\n    case 137: // polygon\n      return '0x4C60051384bd2d3C01bfc845Cf5F4b44bcbE9de5'\n    case 80001: // polygon mumbai\n      return '0x4648a43B2C14Da09FdF82B161150d3F634f40491'\n    case 10: // optimism\n      return '0xb555edF5dcF85f42cEeF1f3630a52A108E55A654'\n    case 420: // optimism goerli\n      return '0x4648a43B2C14Da09FdF82B161150d3F634f40491'\n    case 42161: // arbitrum\n      return '0x4C60051384bd2d3C01bfc845Cf5F4b44bcbE9de5'\n    case 421613: // arbitrum goerli\n      return '0x4648a43B2C14Da09FdF82B161150d3F634f40491'\n    case 42220: // celo\n      return '0xC73d61d192FB994157168Fb56730FdEc64C9Cb8F'\n    case 44787: // celo alfajores\n      return '0x4648a43B2C14Da09FdF82B161150d3F634f40491'\n    case 56: // binance smart chain\n      return '0x5Dc88340E1c5c6366864Ee415d6034cadd1A9897'\n    default:\n      throw new Error(`Universal Router not deployed on chain ${chainId}`)\n  }\n}\n\nexport const WETH_ADDRESS = (chainId: number): string => {\n  switch (chainId) {\n    case 1: //mainnet\n      return '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2'\n    case 5: // goerli\n      return '0xb4fbf271143f4fbf7b91a5ded31805e42b2208d6'\n    case 137: // polygon\n      return '0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270'\n    case 80001: // polygon mumbai\n      return '0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889'\n    case 10: // optimism\n      return '0x4200000000000000000000000000000000000006'\n    case 420: // optimism goerli\n      return '0x4200000000000000000000000000000000000006'\n    case 42161: // arbitrum\n      return '0x82aF49447D8a07e3bd95BD0d56f35241523fBab1'\n    case 421613: // arbitrum goerli\n      return '0xe39Ab88f8A4777030A534146A9Ca3B52bd5D43A3'\n    case 56: // binance smart chain\n      return '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c'\n    default:\n      throw new Error(`WETH9 or UniversalRouter not deployed on chain ${chainId}`)\n  }\n}\n\nexport const PERMIT2_ADDRESS = '0x000000000022D473030F116dDEE9F6B43aC78BA3'\n\nexport const CONTRACT_BALANCE = BigNumber.from(2).pow(255)\nexport const ETH_ADDRESS = '0x0000000000000000000000000000000000000000'\n\nexport const SENDER_AS_RECIPIENT = '0x0000000000000000000000000000000000000001'\nexport const ROUTER_AS_RECIPIENT = '0x0000000000000000000000000000000000000002'\n","import JSBI from 'jsbi'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { Trade as V2Trade, Pair } from '@uniswap/v2-sdk'\nimport { Trade as V3Trade, Pool, encodeRouteToPath } from '@uniswap/v3-sdk'\nimport {\n  Trade as RouterTrade,\n  MixedRouteTrade,\n  Protocol,\n  IRoute,\n  RouteV2,\n  RouteV3,\n  MixedRouteSDK,\n  MixedRoute,\n  SwapOptions as RouterSwapOptions,\n  getOutputOfPools,\n  encodeMixedRouteToPath,\n  partitionMixedRouteByProtocol,\n} from '@uniswap/router-sdk'\nimport { Permit2Permit } from '../../utils/permit2'\nimport { Currency, TradeType, CurrencyAmount, Percent } from '@uniswap/sdk-core'\nimport { Command, RouterTradeType, TradeConfig } from '../Command'\nimport { SENDER_AS_RECIPIENT, ROUTER_AS_RECIPIENT, CONTRACT_BALANCE } from '../../utils/constants'\n\n// the existing router permit object doesn't include enough data for permit2\n// so we extend swap options with the permit2 permit\nexport type SwapOptions = Omit<RouterSwapOptions, 'inputTokenPermit'> & {\n  inputTokenPermit?: Permit2Permit\n}\n\nconst REFUND_ETH_PRICE_IMPACT_THRESHOLD = new Percent(JSBI.BigInt(50), JSBI.BigInt(100))\n\ninterface Swap<TInput extends Currency, TOutput extends Currency> {\n  route: IRoute<TInput, TOutput, Pair | Pool>\n  inputAmount: CurrencyAmount<TInput>\n  outputAmount: CurrencyAmount<TOutput>\n}\n\n// Wrapper for uniswap router-sdk trade entity to encode swaps for Universal Router\n// also translates trade objects from previous (v2, v3) SDKs\nexport class UniswapTrade implements Command {\n  readonly tradeType: RouterTradeType = RouterTradeType.UniswapTrade\n  constructor(public trade: RouterTrade<Currency, Currency, TradeType>, public options: SwapOptions) {}\n\n  encode(planner: RoutePlanner, _config: TradeConfig): void {\n    let payerIsUser = true\n    if (this.trade.inputAmount.currency.isNative) {\n      // TODO: optimize if only one v2 pool we can directly send this to the pool\n      planner.addCommand(CommandType.WRAP_ETH, [\n        ROUTER_AS_RECIPIENT,\n        this.trade.maximumAmountIn(this.options.slippageTolerance).quotient.toString(),\n      ])\n      // since WETH is now owned by the router, the router pays for inputs\n      payerIsUser = false\n    }\n    this.options.recipient = this.options.recipient ?? SENDER_AS_RECIPIENT\n\n    // flag for whether we want to perform slippage check on aggregate output of multiple routes\n    //   1. when there are >2 exact input trades. this is only a heuristic,\n    //      as it's still more gas-expensive even in this case, but has benefits\n    //      in that the reversion probability is lower\n    const performAggregatedSlippageCheck =\n      this.trade.tradeType === TradeType.EXACT_INPUT && this.trade.routes.length > 2\n    const outputIsNative = this.trade.outputAmount.currency.isNative\n    const inputIsNative = this.trade.inputAmount.currency.isNative\n    const routerMustCustody = performAggregatedSlippageCheck || outputIsNative\n\n    for (const swap of this.trade.swaps) {\n      switch (swap.route.protocol) {\n        case Protocol.V2:\n          addV2Swap(planner, swap, this.trade.tradeType, this.options, payerIsUser, routerMustCustody)\n          break\n        case Protocol.V3:\n          addV3Swap(planner, swap, this.trade.tradeType, this.options, payerIsUser, routerMustCustody)\n          break\n        case Protocol.MIXED:\n          addMixedSwap(planner, swap, this.trade.tradeType, this.options, payerIsUser, routerMustCustody)\n          break\n        default:\n          throw new Error('UNSUPPORTED_TRADE_PROTOCOL')\n      }\n    }\n\n    if (routerMustCustody) {\n      if (outputIsNative) {\n        planner.addCommand(CommandType.UNWRAP_WETH, [\n          this.options.recipient,\n          this.trade.minimumAmountOut(this.options.slippageTolerance).quotient.toString(),\n        ])\n      } else {\n        planner.addCommand(CommandType.SWEEP, [\n          this.trade.outputAmount.currency.wrapped.address,\n          this.options.recipient,\n          this.trade.minimumAmountOut(this.options.slippageTolerance).quotient.toString(),\n        ])\n      }\n    }\n\n    if (inputIsNative && (this.trade.tradeType === TradeType.EXACT_OUTPUT || riskOfPartialFill(this.trade))) {\n      // for exactOutput swaps that take native currency as input\n      // we need to send back the change to the user\n      planner.addCommand(CommandType.UNWRAP_WETH, [this.options.recipient, 0])\n    }\n  }\n}\n\n// encode a uniswap v2 swap\nfunction addV2Swap<TInput extends Currency, TOutput extends Currency>(\n  planner: RoutePlanner,\n  { route, inputAmount, outputAmount }: Swap<TInput, TOutput>,\n  tradeType: TradeType,\n  options: SwapOptions,\n  payerIsUser: boolean,\n  routerMustCustody: boolean\n): void {\n  const trade = new V2Trade(\n    route as RouteV2<TInput, TOutput>,\n    tradeType == TradeType.EXACT_INPUT ? inputAmount : outputAmount,\n    tradeType\n  )\n\n  if (tradeType == TradeType.EXACT_INPUT) {\n    planner.addCommand(CommandType.V2_SWAP_EXACT_IN, [\n      // if native, we have to unwrap so keep in the router for now\n      routerMustCustody ? ROUTER_AS_RECIPIENT : options.recipient,\n      trade.maximumAmountIn(options.slippageTolerance).quotient.toString(),\n      trade.minimumAmountOut(options.slippageTolerance).quotient.toString(),\n      route.path.map((pool) => pool.address),\n      payerIsUser,\n    ])\n  } else if (tradeType == TradeType.EXACT_OUTPUT) {\n    planner.addCommand(CommandType.V2_SWAP_EXACT_OUT, [\n      routerMustCustody ? ROUTER_AS_RECIPIENT : options.recipient,\n      trade.minimumAmountOut(options.slippageTolerance).quotient.toString(),\n      trade.maximumAmountIn(options.slippageTolerance).quotient.toString(),\n      route.path.map((pool) => pool.address),\n      payerIsUser,\n    ])\n  }\n}\n\n// encode a uniswap v3 swap\nfunction addV3Swap<TInput extends Currency, TOutput extends Currency>(\n  planner: RoutePlanner,\n  { route, inputAmount, outputAmount }: Swap<TInput, TOutput>,\n  tradeType: TradeType,\n  options: SwapOptions,\n  payerIsUser: boolean,\n  routerMustCustody: boolean\n): void {\n  const trade = V3Trade.createUncheckedTrade({\n    route: route as RouteV3<TInput, TOutput>,\n    inputAmount,\n    outputAmount,\n    tradeType,\n  })\n\n  const path = encodeRouteToPath(route as RouteV3<TInput, TOutput>, trade.tradeType === TradeType.EXACT_OUTPUT)\n  if (tradeType == TradeType.EXACT_INPUT) {\n    planner.addCommand(CommandType.V3_SWAP_EXACT_IN, [\n      routerMustCustody ? ROUTER_AS_RECIPIENT : options.recipient,\n      trade.maximumAmountIn(options.slippageTolerance).quotient.toString(),\n      trade.minimumAmountOut(options.slippageTolerance).quotient.toString(),\n      path,\n      payerIsUser,\n    ])\n  } else if (tradeType == TradeType.EXACT_OUTPUT) {\n    planner.addCommand(CommandType.V3_SWAP_EXACT_OUT, [\n      routerMustCustody ? ROUTER_AS_RECIPIENT : options.recipient,\n      trade.minimumAmountOut(options.slippageTolerance).quotient.toString(),\n      trade.maximumAmountIn(options.slippageTolerance).quotient.toString(),\n      path,\n      payerIsUser,\n    ])\n  }\n}\n\n// encode a mixed route swap, i.e. including both v2 and v3 pools\nfunction addMixedSwap<TInput extends Currency, TOutput extends Currency>(\n  planner: RoutePlanner,\n  swap: Swap<TInput, TOutput>,\n  tradeType: TradeType,\n  options: SwapOptions,\n  payerIsUser: boolean,\n  routerMustCustody: boolean\n): void {\n  const { route, inputAmount, outputAmount } = swap\n  const tradeRecipient = routerMustCustody ? ROUTER_AS_RECIPIENT : options.recipient\n\n  // single hop, so it can be reduced to plain v2 or v3 swap logic\n  if (route.pools.length === 1) {\n    if (route.pools[0] instanceof Pool) {\n      return addV3Swap(planner, swap, tradeType, options, payerIsUser, routerMustCustody)\n    } else if (route.pools[0] instanceof Pair) {\n      return addV2Swap(planner, swap, tradeType, options, payerIsUser, routerMustCustody)\n    } else {\n      throw new Error('Invalid route type')\n    }\n  }\n\n  const trade = MixedRouteTrade.createUncheckedTrade({\n    route: route as MixedRoute<TInput, TOutput>,\n    inputAmount,\n    outputAmount,\n    tradeType,\n  })\n\n  const amountIn = trade.maximumAmountIn(options.slippageTolerance, inputAmount).quotient.toString()\n  const amountOut = trade.minimumAmountOut(options.slippageTolerance, outputAmount).quotient.toString()\n\n  // logic from\n  // https://github.com/Uniswap/router-sdk/blob/d8eed164e6c79519983844ca8b6a3fc24ebcb8f8/src/swapRouter.ts#L276\n  const sections = partitionMixedRouteByProtocol(route as MixedRoute<TInput, TOutput>)\n  const isLastSectionInRoute = (i: number) => {\n    return i === sections.length - 1\n  }\n\n  let outputToken\n  let inputToken = route.input.wrapped\n\n  for (let i = 0; i < sections.length; i++) {\n    const section = sections[i]\n    /// Now, we get output of this section\n    outputToken = getOutputOfPools(section, inputToken)\n\n    const newRouteOriginal = new MixedRouteSDK(\n      [...section],\n      section[0].token0.equals(inputToken) ? section[0].token0 : section[0].token1,\n      outputToken\n    )\n    const newRoute = new MixedRoute(newRouteOriginal)\n\n    /// Previous output is now input\n    inputToken = outputToken\n\n    const mixedRouteIsAllV3 = (route: MixedRouteSDK<Currency, Currency>) => {\n      return route.pools.every((pool) => pool instanceof Pool)\n    }\n\n    if (mixedRouteIsAllV3(newRoute)) {\n      const path: string = encodeMixedRouteToPath(newRoute)\n\n      planner.addCommand(CommandType.V3_SWAP_EXACT_IN, [\n        // if not last section: send tokens directly to the first v2 pair of the next section\n        // note: because of the partitioning function we can be sure that the next section is v2\n        isLastSectionInRoute(i) ? tradeRecipient : (sections[i + 1][0] as Pair).liquidityToken.address,\n        i == 0 ? amountIn : CONTRACT_BALANCE, // amountIn\n        !isLastSectionInRoute(i) ? 0 : amountOut, // amountOut\n        path, // path\n        payerIsUser && i === 0, // payerIsUser\n      ])\n    } else {\n      planner.addCommand(CommandType.V2_SWAP_EXACT_IN, [\n        isLastSectionInRoute(i) ? tradeRecipient : ROUTER_AS_RECIPIENT, // recipient\n        i === 0 ? amountIn : CONTRACT_BALANCE, // amountIn\n        !isLastSectionInRoute(i) ? 0 : amountOut, // amountOutMin\n        newRoute.path.map((pool) => pool.address), // path\n        payerIsUser && i === 0,\n      ])\n    }\n  }\n}\n\n// if price impact is very high, there's a chance of hitting max/min prices resulting in a partial fill of the swap\nfunction riskOfPartialFill(trade: RouterTrade<Currency, Currency, TradeType>): boolean {\n  return trade.priceImpact.greaterThan(REFUND_ETH_PRICE_IMPACT_THRESHOLD)\n}\n","import { ethers } from 'ethers'\nimport { PermitSingle } from '@uniswap/permit2-sdk'\nimport { CommandType, RoutePlanner } from './routerCommands'\n\nexport interface Permit2Permit extends PermitSingle {\n  signature: string\n}\n\nconst SIGNATURE_LENGTH = 65\nconst EIP_2098_SIGNATURE_LENGTH = 64\n\nexport function encodePermit(planner: RoutePlanner, permit: Permit2Permit): void {\n  let signature = permit.signature\n\n  const length = ethers.utils.arrayify(permit.signature).length\n  // signature data provided for EIP-1271 may have length different from ECDSA signature\n  if (length === SIGNATURE_LENGTH || length === EIP_2098_SIGNATURE_LENGTH) {\n    // sanitizes signature to cover edge cases of malformed EIP-2098 sigs and v used as recovery id\n    signature = ethers.utils.joinSignature(ethers.utils.splitSignature(permit.signature))\n  }\n\n  planner.addCommand(CommandType.PERMIT, [permit, signature])\n}\n","import invariant from 'tiny-invariant'\nimport { abi } from '@uniswap/universal-router/artifacts/contracts/UniversalRouter.sol/UniversalRouter.json'\nimport { Interface } from '@ethersproject/abi'\nimport { BigNumber, BigNumberish } from 'ethers'\nimport { MethodParameters } from '@uniswap/v3-sdk'\nimport { Trade as RouterTrade } from '@uniswap/router-sdk'\nimport { Currency, TradeType } from '@uniswap/sdk-core'\nimport { Command, RouterTradeType } from './entities/Command'\nimport { NFTTrade, SupportedProtocolsData } from './entities/NFTTrade'\nimport { UniswapTrade, SwapOptions } from './entities/protocols/uniswap'\nimport { UnwrapWETH } from './entities/protocols/unwrapWETH'\nimport { CommandType, RoutePlanner } from './utils/routerCommands'\nimport { encodePermit } from './utils/permit2'\nimport { ROUTER_AS_RECIPIENT, SENDER_AS_RECIPIENT, ETH_ADDRESS } from './utils/constants'\n\nexport type SwapRouterConfig = {\n  sender?: string // address\n  deadline?: BigNumberish\n}\n\ntype SupportedNFTTrade = NFTTrade<SupportedProtocolsData>\n\nexport abstract class SwapRouter {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  public static swapCallParameters(trades: Command[] | Command, config: SwapRouterConfig = {}): MethodParameters {\n    if (!Array.isArray(trades)) trades = [trades]\n\n    const nftTrades = trades.filter((trade, _, []) => trade.hasOwnProperty('market')) as SupportedNFTTrade[]\n    const allowRevert = nftTrades.length == 1 && nftTrades[0].orders.length == 1 ? false : true\n    const planner = new RoutePlanner()\n\n    // track value flow to require the right amount of native value\n    let currentNativeValueInRouter = BigNumber.from(0)\n    let transactionValue = BigNumber.from(0)\n\n    for (const trade of trades) {\n      /**\n       * is NFTTrade\n       */\n      if (trade.tradeType == RouterTradeType.NFTTrade) {\n        const nftTrade = trade as SupportedNFTTrade\n        nftTrade.encode(planner, { allowRevert })\n        const tradePrice = nftTrade.getTotalPrice()\n\n        // send enough native value to contract for NFT purchase\n        if (currentNativeValueInRouter.lt(tradePrice)) {\n          transactionValue = transactionValue.add(tradePrice.sub(currentNativeValueInRouter))\n          currentNativeValueInRouter = BigNumber.from(0)\n        } else {\n          currentNativeValueInRouter = currentNativeValueInRouter.sub(tradePrice)\n        }\n        /**\n         * is Uniswap Trade\n         */\n      } else if (trade.tradeType == RouterTradeType.UniswapTrade) {\n        const uniswapTrade = trade as UniswapTrade\n        const inputIsNative = uniswapTrade.trade.inputAmount.currency.isNative\n        const outputIsNative = uniswapTrade.trade.outputAmount.currency.isNative\n        const swapOptions = uniswapTrade.options\n\n        invariant(!(inputIsNative && !!swapOptions.inputTokenPermit), 'NATIVE_INPUT_PERMIT')\n\n        if (!!swapOptions.inputTokenPermit) {\n          encodePermit(planner, swapOptions.inputTokenPermit)\n        }\n\n        if (inputIsNative) {\n          transactionValue = transactionValue.add(\n            BigNumber.from(uniswapTrade.trade.maximumAmountIn(swapOptions.slippageTolerance).quotient.toString())\n          )\n        }\n        // track amount of native currency in the router\n        if (outputIsNative && swapOptions.recipient == ROUTER_AS_RECIPIENT) {\n          currentNativeValueInRouter = currentNativeValueInRouter.add(\n            BigNumber.from(uniswapTrade.trade.minimumAmountOut(swapOptions.slippageTolerance).quotient.toString())\n          )\n        }\n        uniswapTrade.encode(planner, { allowRevert: false })\n        /**\n         * is UnwrapWETH\n         */\n      } else if (trade.tradeType == RouterTradeType.UnwrapWETH) {\n        const UnwrapWETH = trade as UnwrapWETH\n        trade.encode(planner, { allowRevert: false })\n        currentNativeValueInRouter = currentNativeValueInRouter.add(UnwrapWETH.amount)\n        /**\n         * else\n         */\n      } else {\n        throw 'trade must be of instance: UniswapTrade or NFTTrade'\n      }\n    }\n\n    // TODO: matches current logic for now, but should eventually only sweep for multiple NFT trades\n    // or NFT trades with potential slippage (i.e. sudo)\n    if (nftTrades.length > 0) planner.addCommand(CommandType.SWEEP, [ETH_ADDRESS, SENDER_AS_RECIPIENT, 0])\n    return SwapRouter.encodePlan(planner, transactionValue, config)\n  }\n\n  /**\n   * @deprecated in favor of swapCallParameters. Update before next major version 2.0.0\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given swap.\n   * @param trades to produce call parameters for\n   */\n  public static swapNFTCallParameters(trades: SupportedNFTTrade[], config: SwapRouterConfig = {}): MethodParameters {\n    let planner = new RoutePlanner()\n    let totalPrice = BigNumber.from(0)\n\n    const allowRevert = trades.length == 1 && trades[0].orders.length == 1 ? false : true\n\n    for (const trade of trades) {\n      trade.encode(planner, { allowRevert })\n      totalPrice = totalPrice.add(trade.getTotalPrice())\n    }\n\n    planner.addCommand(CommandType.SWEEP, [ETH_ADDRESS, SENDER_AS_RECIPIENT, 0])\n    return SwapRouter.encodePlan(planner, totalPrice, config)\n  }\n\n  /**\n   * @deprecated in favor of swapCallParameters. Update before next major version 2.0.0\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\n   * @param trades to produce call parameters for\n   * @param options options for the call parameters\n   */\n  public static swapERC20CallParameters(\n    trades: RouterTrade<Currency, Currency, TradeType>,\n    options: SwapOptions\n  ): MethodParameters {\n    // TODO: use permit if signature included in swapOptions\n    const planner = new RoutePlanner()\n\n    const trade: UniswapTrade = new UniswapTrade(trades, options)\n\n    const inputCurrency = trade.trade.inputAmount.currency\n    invariant(!(inputCurrency.isNative && !!options.inputTokenPermit), 'NATIVE_INPUT_PERMIT')\n\n    if (options.inputTokenPermit) {\n      encodePermit(planner, options.inputTokenPermit)\n    }\n\n    const nativeCurrencyValue = inputCurrency.isNative\n      ? BigNumber.from(trade.trade.maximumAmountIn(options.slippageTolerance).quotient.toString())\n      : BigNumber.from(0)\n\n    trade.encode(planner, { allowRevert: false })\n    return SwapRouter.encodePlan(planner, nativeCurrencyValue, {\n      deadline: options.deadlineOrPreviousBlockhash ? BigNumber.from(options.deadlineOrPreviousBlockhash) : undefined,\n    })\n    return SwapRouter.encodePlan(planner, nativeCurrencyValue)\n  }\n\n  /**\n   * Encodes a planned route into a method name and parameters for the Router contract.\n   * @param planner the planned route\n   * @param nativeCurrencyValue the native currency value of the planned route\n   * @param config the router config\n   */\n  private static encodePlan(\n    planner: RoutePlanner,\n    nativeCurrencyValue: BigNumber,\n    config: SwapRouterConfig = {}\n  ): MethodParameters {\n    const { commands, inputs } = planner\n    const functionSignature = !!config.deadline ? 'execute(bytes,bytes[],uint256)' : 'execute(bytes,bytes[])'\n    const parameters = !!config.deadline ? [commands, inputs, config.deadline] : [commands, inputs]\n    const calldata = SwapRouter.INTERFACE.encodeFunctionData(functionSignature, parameters)\n    return { calldata, value: nativeCurrencyValue.toHexString() }\n  }\n}\n","import invariant from 'tiny-invariant'\nimport { BigNumber, BigNumberish } from 'ethers'\nimport { SeaportData } from './protocols/seaport'\nimport { FoundationData } from './protocols/foundation'\nimport { NFTXData } from './protocols/nftx'\nimport { NFT20Data } from './protocols/nft20'\nimport { RoutePlanner } from '../utils/routerCommands'\nimport { Command, RouterTradeType, TradeConfig } from './Command'\nimport { LooksRareData } from './protocols/looksRare'\nimport { SudoswapData } from './protocols/sudoswap'\nimport { CryptopunkData } from './protocols/cryptopunk'\nimport { X2Y2Data } from './protocols/x2y2'\n\nexport type SupportedProtocolsData =\n  | SeaportData\n  | FoundationData\n  | NFTXData\n  | LooksRareData\n  | X2Y2Data\n  | CryptopunkData\n  | NFT20Data\n  | SudoswapData\n\nexport abstract class NFTTrade<T> implements Command {\n  readonly tradeType: RouterTradeType = RouterTradeType.NFTTrade\n  readonly orders: T[]\n  readonly market: Market\n\n  constructor(market: Market, orders: T[]) {\n    invariant(orders.length > 0, 'no buy Items')\n    this.market = market\n    this.orders = orders\n  }\n\n  abstract encode(planner: RoutePlanner, config: TradeConfig): void\n\n  abstract getBuyItems(): BuyItem[]\n\n  abstract getTotalPrice(): BigNumber\n}\n\nexport type BuyItem = {\n  tokenAddress: string\n  tokenId: BigNumberish\n  tokenType: TokenType\n  amount?: BigNumberish // for 1155\n}\n\nexport enum Market {\n  Foundation = 'foundation',\n  LooksRare = 'looksrare',\n  NFT20 = 'nft20',\n  NFTX = 'nftx',\n  Seaport = 'seaport',\n  Sudoswap = 'Sudoswap',\n  Cryptopunks = 'cryptopunks',\n  X2Y2 = 'x2y2',\n}\n\nexport enum TokenType {\n  ERC721 = 'ERC721',\n  ERC1155 = 'ERC1155',\n  Cryptopunk = 'Cryptopunk',\n}\n","import { TradeConfig } from '../Command'\nimport { NFTTrade, Market, TokenType, BuyItem } from '../NFTTrade'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { BigNumber, BigNumberish } from 'ethers'\n\nexport type CryptopunkData = {\n  tokenId: BigNumberish\n  recipient: string\n  value: BigNumberish\n}\n\nexport class CryptopunkTrade extends NFTTrade<CryptopunkData> {\n  public static CRYPTOPUNK_ADDRESS: string = '0xb47e3cd837ddf8e4c57f05d70ab865de6e193bbb'\n\n  constructor(orders: CryptopunkData[]) {\n    super(Market.Cryptopunks, orders)\n  }\n\n  encode(planner: RoutePlanner, config: TradeConfig): void {\n    for (const item of this.orders) {\n      planner.addCommand(CommandType.CRYPTOPUNKS, [item.tokenId, item.recipient, item.value], config.allowRevert)\n    }\n  }\n\n  getBuyItems(): BuyItem[] {\n    let buyItems: BuyItem[] = []\n    for (const item of this.orders) {\n      buyItems.push({\n        tokenAddress: CryptopunkTrade.CRYPTOPUNK_ADDRESS,\n        tokenId: item.tokenId,\n        tokenType: TokenType.Cryptopunk,\n      })\n    }\n    return buyItems\n  }\n\n  getTotalPrice(): BigNumber {\n    let total = BigNumber.from(0)\n    for (const item of this.orders) {\n      total = total.add(item.value)\n    }\n    return total\n  }\n}\n","import abi from '../../../abis/Foundation.json'\nimport { Interface } from '@ethersproject/abi'\nimport { BuyItem, Market, NFTTrade, TokenType } from '../NFTTrade'\nimport { TradeConfig } from '../Command'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { BigNumber, BigNumberish } from 'ethers'\n\nexport type FoundationData = {\n  recipient: string\n  tokenAddress: string\n  tokenId: BigNumberish\n  price: BigNumberish\n  referrer: string // address\n}\n\nexport class FoundationTrade extends NFTTrade<FoundationData> {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  constructor(orders: FoundationData[]) {\n    super(Market.Foundation, orders)\n  }\n\n  encode(planner: RoutePlanner, config: TradeConfig): void {\n    for (const item of this.orders) {\n      const calldata = FoundationTrade.INTERFACE.encodeFunctionData('buyV2', [\n        item.tokenAddress,\n        item.tokenId,\n        item.price,\n        item.referrer,\n      ])\n      planner.addCommand(\n        CommandType.FOUNDATION,\n        [item.price, calldata, item.recipient, item.tokenAddress, item.tokenId],\n        config.allowRevert\n      )\n    }\n  }\n\n  getBuyItems(): BuyItem[] {\n    let buyItems: BuyItem[] = []\n    for (const item of this.orders) {\n      buyItems.push({\n        tokenAddress: item.tokenAddress,\n        tokenId: item.tokenId,\n        tokenType: TokenType.ERC721,\n      })\n    }\n    return buyItems\n  }\n\n  getTotalPrice(): BigNumber {\n    let total = BigNumber.from(0)\n    for (const item of this.orders) {\n      total = total.add(item.price)\n    }\n    return total\n  }\n}\n","import invariant from 'tiny-invariant'\nimport abi from '../../../abis/LooksRare.json'\nimport { Interface } from '@ethersproject/abi'\nimport { BuyItem, Market, NFTTrade, TokenType } from '../NFTTrade'\nimport { TradeConfig } from '../Command'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { BigNumber, BigNumberish } from 'ethers'\n\nexport type MakerOrder = {\n  collection: string\n  tokenId: BigNumberish\n  isOrderAsk: true\n  signer: string\n  strategy: string\n  currency: string\n  amount: BigNumberish\n  price: BigNumberish\n  minPercentageToAsk: BigNumberish\n  nonce: BigNumberish\n  startTime: BigNumberish\n  endTime: BigNumberish\n  v: BigNumberish\n  r: string\n  s: string\n  params: string\n}\n\nexport type TakerOrder = {\n  minPercentageToAsk: BigNumberish\n  price: BigNumberish\n  taker: string\n  tokenId: BigNumberish\n  isOrderAsk: boolean\n  params: string\n}\n\nexport type LooksRareData = {\n  makerOrder: MakerOrder\n  takerOrder: TakerOrder\n  recipient: string\n  tokenType: TokenType\n}\n\nexport class LooksRareTrade extends NFTTrade<LooksRareData> {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  constructor(orders: LooksRareData[]) {\n    super(Market.LooksRare, orders)\n  }\n\n  encode(planner: RoutePlanner, config: TradeConfig): void {\n    for (const item of this.orders) {\n      const calldata = LooksRareTrade.INTERFACE.encodeFunctionData('matchAskWithTakerBidUsingETHAndWETH', [\n        item.takerOrder,\n        item.makerOrder,\n      ])\n\n      if (item.tokenType == TokenType.ERC721) {\n        invariant(item.makerOrder.amount == 1, 'ERC721 token amount must be 1')\n        planner.addCommand(\n          CommandType.LOOKS_RARE_721,\n          [item.makerOrder.price, calldata, item.recipient, item.makerOrder.collection, item.makerOrder.tokenId],\n          config.allowRevert\n        )\n      } else if (item.tokenType == TokenType.ERC1155) {\n        planner.addCommand(\n          CommandType.LOOKS_RARE_1155,\n          [\n            item.makerOrder.price,\n            calldata,\n            item.recipient,\n            item.makerOrder.collection,\n            item.makerOrder.tokenId,\n            item.makerOrder.amount,\n          ],\n          config.allowRevert\n        )\n      }\n    }\n  }\n\n  getBuyItems(): BuyItem[] {\n    let buyItems: BuyItem[] = []\n    for (const item of this.orders) {\n      buyItems.push({\n        tokenAddress: item.makerOrder.collection,\n        tokenId: item.makerOrder.tokenId,\n        tokenType: item.tokenType,\n      })\n    }\n    return buyItems\n  }\n\n  getTotalPrice(): BigNumber {\n    let total = BigNumber.from(0)\n    for (const item of this.orders) {\n      total = total.add(item.makerOrder.price)\n    }\n    return total\n  }\n}\n","import abi from '../../../abis/NFT20.json'\nimport { Interface } from '@ethersproject/abi'\nimport { TradeConfig } from '../Command'\nimport { NFTTrade, Market, TokenType, BuyItem } from '../NFTTrade'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { BigNumber, BigNumberish } from 'ethers'\n\nexport type NFT20Data = {\n  tokenAddress: string\n  tokenIds: BigNumberish[]\n  tokenAmounts: BigNumberish[]\n  recipient: string\n  fee: BigNumberish\n  isV3: boolean\n  value: BigNumberish\n}\n\nexport class NFT20Trade extends NFTTrade<NFT20Data> {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  constructor(orders: NFT20Data[]) {\n    super(Market.NFT20, orders)\n  }\n\n  encode(planner: RoutePlanner, config: TradeConfig): void {\n    for (const order of this.orders) {\n      const calldata = NFT20Trade.INTERFACE.encodeFunctionData('ethForNft', [\n        order.tokenAddress,\n        order.tokenIds,\n        order.tokenAmounts,\n        order.recipient,\n        order.fee,\n        order.isV3,\n      ])\n      planner.addCommand(CommandType.NFT20, [order.value, calldata], config.allowRevert)\n    }\n  }\n\n  getBuyItems(): BuyItem[] {\n    let buyItems: BuyItem[] = []\n    for (const pool of this.orders) {\n      for (const tokenId of pool.tokenIds) {\n        buyItems.push({\n          tokenAddress: pool.tokenAddress,\n          tokenId: tokenId,\n          tokenType: TokenType.ERC721,\n        })\n      }\n    }\n\n    return buyItems\n  }\n\n  getTotalPrice(): BigNumber {\n    let total = BigNumber.from(0)\n    for (const item of this.orders) {\n      total = total.add(item.value)\n    }\n    return total\n  }\n}\n","import abi from '../../../abis/NFTXZap.json'\nimport { Interface } from '@ethersproject/abi'\nimport { BuyItem, Market, NFTTrade, TokenType } from '../NFTTrade'\nimport { TradeConfig } from '../Command'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { BigNumber, BigNumberish } from 'ethers'\nimport { Ether } from '@uniswap/sdk-core'\n\nexport type NFTXData = {\n  recipient: string\n  vaultAddress: string\n  vaultId: BigNumberish\n  tokenAddress: string\n  tokenIds: BigNumberish[]\n  value: BigNumber\n}\n\nexport class NFTXTrade extends NFTTrade<NFTXData> {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  constructor(orders: NFTXData[]) {\n    super(Market.NFTX, orders)\n  }\n\n  encode(planner: RoutePlanner, config: TradeConfig): void {\n    for (const order of this.orders) {\n      const calldata = NFTXTrade.INTERFACE.encodeFunctionData('buyAndRedeem', [\n        order.vaultId,\n        order.tokenIds.length,\n        order.tokenIds,\n        [Ether.onChain(1).wrapped.address, order.vaultAddress],\n        order.recipient,\n      ])\n      planner.addCommand(CommandType.NFTX, [order.value, calldata], config.allowRevert)\n    }\n  }\n\n  getBuyItems(): BuyItem[] {\n    let buyItems: BuyItem[] = []\n    for (const order of this.orders) {\n      for (const tokenId of order.tokenIds) {\n        buyItems.push({\n          tokenAddress: order.tokenAddress,\n          tokenId: tokenId,\n          tokenType: TokenType.ERC721,\n        })\n      }\n    }\n    return buyItems\n  }\n\n  getTotalPrice(): BigNumber {\n    let total = BigNumber.from(0)\n    for (const item of this.orders) {\n      total = total.add(item.value)\n    }\n    return total\n  }\n}\n","import abi from '../../../abis/Seaport.json'\nimport { BigNumber, BigNumberish } from 'ethers'\nimport { Interface } from '@ethersproject/abi'\nimport { BuyItem, Market, NFTTrade, TokenType } from '../NFTTrade'\nimport { TradeConfig } from '../Command'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\n\nexport type SeaportData = {\n  items: Order[]\n  recipient: string // address\n}\n\nexport type FulfillmentComponent = {\n  orderIndex: BigNumberish\n  itemIndex: BigNumberish\n}\n\nexport type OfferItem = {\n  itemType: BigNumberish // enum\n  token: string // address\n  identifierOrCriteria: BigNumberish\n  startAmount: BigNumberish\n  endAmount: BigNumberish\n}\n\nexport type ConsiderationItem = OfferItem & {\n  recipient: string\n}\n\nexport type Order = {\n  parameters: OrderParameters\n  signature: string\n}\n\ntype OrderParameters = {\n  offerer: string // address,\n  offer: OfferItem[]\n  consideration: ConsiderationItem[]\n  orderType: BigNumberish // enum\n  startTime: BigNumberish\n  endTime: BigNumberish\n  zoneHash: string // bytes32\n  zone: string // address\n  salt: BigNumberish\n  conduitKey: string // bytes32,\n  totalOriginalConsiderationItems: BigNumberish\n}\n\nexport type AdvancedOrder = Order & {\n  numerator: BigNumber // uint120\n  denominator: BigNumber // uint120\n  extraData: string // bytes\n}\n\nexport class SeaportTrade extends NFTTrade<SeaportData> {\n  public static INTERFACE: Interface = new Interface(abi)\n  public static OPENSEA_CONDUIT_KEY: string = '0x0000007b02230091a7ed01230072f7006a004d60a8d4e71d599b8104250f0000'\n\n  constructor(orders: SeaportData[]) {\n    super(Market.Seaport, orders)\n  }\n\n  encode(planner: RoutePlanner, config: TradeConfig): void {\n    for (const order of this.orders) {\n      let advancedOrders: AdvancedOrder[] = []\n      let orderFulfillments: FulfillmentComponent[][] = order.items.map((_, index) => [\n        { orderIndex: index, itemIndex: 0 },\n      ])\n      let considerationFulFillments: FulfillmentComponent[][] = this.getConsiderationFulfillments(order.items)\n\n      for (const item of order.items) {\n        const { advancedOrder } = this.getAdvancedOrderParams(item)\n        advancedOrders.push(advancedOrder)\n      }\n\n      let calldata: string\n      if (advancedOrders.length == 1) {\n        calldata = SeaportTrade.INTERFACE.encodeFunctionData('fulfillAdvancedOrder', [\n          advancedOrders[0],\n          [],\n          SeaportTrade.OPENSEA_CONDUIT_KEY,\n          order.recipient,\n        ])\n      } else {\n        calldata = SeaportTrade.INTERFACE.encodeFunctionData('fulfillAvailableAdvancedOrders', [\n          advancedOrders,\n          [],\n          orderFulfillments,\n          considerationFulFillments,\n          SeaportTrade.OPENSEA_CONDUIT_KEY,\n          order.recipient,\n          100, // TODO: look into making this a better number\n        ])\n      }\n      planner.addCommand(CommandType.SEAPORT, [this.getTotalPrice().toString(), calldata], config.allowRevert)\n    }\n  }\n\n  getBuyItems(): BuyItem[] {\n    let buyItems: BuyItem[] = []\n    for (const order of this.orders) {\n      for (const item of order.items) {\n        for (const offer of item.parameters.offer) {\n          buyItems.push({\n            tokenAddress: offer.token,\n            tokenId: offer.identifierOrCriteria,\n            tokenType: TokenType.ERC721,\n          })\n        }\n      }\n    }\n    return buyItems\n  }\n\n  getTotalPrice(): BigNumber {\n    let totalPrice = BigNumber.from(0)\n    for (const order of this.orders) {\n      for (const item of order.items) {\n        totalPrice = totalPrice.add(this.calculateValue(item.parameters.consideration))\n      }\n    }\n    return totalPrice\n  }\n\n  private getConsiderationFulfillments(protocolDatas: Order[]): FulfillmentComponent[][] {\n    let considerationFulfillments: FulfillmentComponent[][] = []\n    const considerationRecipients: string[] = []\n\n    for (const i in protocolDatas) {\n      const protocolData = protocolDatas[i]\n\n      for (const j in protocolData.parameters.consideration) {\n        const item = protocolData.parameters.consideration[j]\n\n        if (considerationRecipients.findIndex((x) => x === item.recipient) === -1) {\n          considerationRecipients.push(item.recipient)\n        }\n\n        const recipientIndex = considerationRecipients.findIndex((x) => x === item.recipient)\n\n        if (!considerationFulfillments[recipientIndex]) {\n          considerationFulfillments.push([\n            {\n              orderIndex: i,\n              itemIndex: j,\n            },\n          ])\n        } else {\n          considerationFulfillments[recipientIndex].push({\n            orderIndex: i,\n            itemIndex: j,\n          })\n        }\n      }\n    }\n    return considerationFulfillments\n  }\n\n  private getAdvancedOrderParams(data: Order): { advancedOrder: AdvancedOrder; value: BigNumber } {\n    const advancedOrder = {\n      parameters: data.parameters,\n      numerator: BigNumber.from('1'),\n      denominator: BigNumber.from('1'),\n      signature: data.signature,\n      extraData: '0x00',\n    }\n    const value = this.calculateValue(data.parameters.consideration)\n    return { advancedOrder, value }\n  }\n\n  private calculateValue(considerations: ConsiderationItem[]): BigNumber {\n    return considerations.reduce(\n      (amt: BigNumber, consideration: ConsiderationItem) => amt.add(consideration.startAmount),\n      BigNumber.from(0)\n    )\n  }\n}\n","import abi from '../../../abis/Sudoswap.json'\nimport { Interface } from '@ethersproject/abi'\nimport { BuyItem, Market, NFTTrade, TokenType } from '../NFTTrade'\nimport { TradeConfig } from '../Command'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { BigNumber, BigNumberish } from 'ethers'\n\ntype PairSwap = {\n  swapInfo: {\n    pair: string // address\n    nftIds: BigNumberish[]\n  }\n  tokenAddress: string // address\n  maxCost: BigNumberish\n}\n\nexport type SudoswapData = {\n  swaps: PairSwap[]\n  nftRecipient: string\n  ethRecipient: string\n  deadline: BigNumberish\n}\n\nexport class SudoswapTrade extends NFTTrade<SudoswapData> {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  constructor(orders: SudoswapData[]) {\n    super(Market.Sudoswap, orders)\n  }\n\n  encode(planner: RoutePlanner, config: TradeConfig): void {\n    for (const order of this.orders) {\n      const calldata = SudoswapTrade.INTERFACE.encodeFunctionData('robustSwapETHForSpecificNFTs', [\n        order.swaps.map((swap) => {\n          return { swapInfo: swap.swapInfo, maxCost: swap.maxCost }\n        }),\n        order.ethRecipient,\n        order.nftRecipient,\n        order.deadline,\n      ])\n      const value = order.swaps.reduce((prevVal, swap) => {\n        return prevVal.add(swap.maxCost)\n      }, BigNumber.from(0))\n      planner.addCommand(CommandType.SUDOSWAP, [value, calldata], config.allowRevert)\n    }\n  }\n\n  getBuyItems(): BuyItem[] {\n    let buyItems: BuyItem[] = []\n    for (const order of this.orders) {\n      for (const swap of order.swaps) {\n        for (const tokenId of swap.swapInfo.nftIds) {\n          buyItems.push({\n            tokenAddress: swap.tokenAddress,\n            tokenId,\n            tokenType: TokenType.ERC721,\n          })\n        }\n      }\n    }\n    return buyItems\n  }\n\n  getTotalPrice(): BigNumber {\n    let total = BigNumber.from(0)\n    for (const order of this.orders) {\n      for (const swap of order.swaps) {\n        total = total.add(swap.maxCost)\n      }\n    }\n    return total\n  }\n}\n","import abi from '../../../abis/X2Y2.json'\nimport { Interface } from '@ethersproject/abi'\nimport { BuyItem, Market, NFTTrade, TokenType } from '../NFTTrade'\nimport { TradeConfig } from '../Command'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { BigNumber, BigNumberish } from 'ethers'\n\ntype X2Y2PartialData = {\n  signedInput: string\n  recipient: string\n  tokenAddress: string\n  tokenId: BigNumberish\n  price: BigNumberish\n}\n\nexport type X2Y2_721_Data = X2Y2PartialData & {\n  tokenType: TokenType.ERC721\n}\n\nexport type X2Y2_1155_Data = X2Y2PartialData & {\n  tokenType: TokenType.ERC1155\n  tokenAmount: BigNumberish\n}\n\nexport type X2Y2Data = X2Y2_721_Data | X2Y2_1155_Data\n\nexport class X2Y2Trade extends NFTTrade<X2Y2Data> {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  constructor(orders: X2Y2Data[]) {\n    super(Market.X2Y2, orders)\n  }\n\n  encode(planner: RoutePlanner, config: TradeConfig): void {\n    for (const item of this.orders) {\n      const functionSelector = X2Y2Trade.INTERFACE.getSighash(X2Y2Trade.INTERFACE.getFunction('run'))\n      const calldata = functionSelector + item.signedInput.slice(2)\n\n      if (item.tokenType == TokenType.ERC721) {\n        planner.addCommand(\n          CommandType.X2Y2_721,\n          [item.price, calldata, item.recipient, item.tokenAddress, item.tokenId],\n          config.allowRevert\n        )\n      } else if (item.tokenType == TokenType.ERC1155) {\n        planner.addCommand(\n          CommandType.X2Y2_1155,\n          [item.price, calldata, item.recipient, item.tokenAddress, item.tokenId, item.tokenAmount],\n          config.allowRevert\n        )\n      }\n    }\n  }\n\n  getBuyItems(): BuyItem[] {\n    let buyItems: BuyItem[] = []\n    for (const item of this.orders) {\n      buyItems.push({\n        tokenAddress: item.tokenAddress,\n        tokenId: item.tokenId,\n        tokenType: item.tokenType,\n      })\n    }\n    return buyItems\n  }\n\n  getTotalPrice(): BigNumber {\n    let total = BigNumber.from(0)\n    for (const item of this.orders) {\n      total = total.add(item.price)\n    }\n    return total\n  }\n}\n","import invariant from 'tiny-invariant'\nimport { BigNumberish } from 'ethers'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { Permit2Permit } from '../../utils/permit2'\nimport { Command, RouterTradeType, TradeConfig } from '../Command'\nimport { encodePermit } from '../../utils/permit2'\nimport { ROUTER_AS_RECIPIENT, UNIVERSAL_ROUTER_ADDRESS, WETH_ADDRESS } from '../../utils/constants'\n\nexport class UnwrapWETH implements Command {\n  readonly tradeType: RouterTradeType = RouterTradeType.UnwrapWETH\n  readonly permit2Data: Permit2Permit\n  readonly wethAddress: string\n  readonly routerAddress: string\n  readonly amount: BigNumberish\n\n  constructor(amount: BigNumberish, chainId: number, permit2?: Permit2Permit) {\n    this.wethAddress = WETH_ADDRESS(chainId)\n    this.routerAddress = UNIVERSAL_ROUTER_ADDRESS(chainId)\n    this.amount = amount\n\n    if (!!permit2) {\n      invariant(permit2.details.token === this.wethAddress, `must be permitting WETH address: ${this.wethAddress}`)\n      invariant(permit2.details.amount >= amount, `Did not permit enough WETH for unwrapWETH transaction`)\n      this.permit2Data = permit2\n    }\n  }\n\n  encode(planner: RoutePlanner, _: TradeConfig): void {\n    if (!!this.permit2Data) encodePermit(planner, this.permit2Data)\n    planner.addCommand(CommandType.PERMIT2_TRANSFER_FROM, [this.wethAddress, this.routerAddress, this.amount])\n    planner.addCommand(CommandType.UNWRAP_WETH, [ROUTER_AS_RECIPIENT, this.amount])\n  }\n}\n"]},"metadata":{},"sourceType":"script"}